// Generated by LiveScript 1.2.0
var Url, assert, less, Session, ref$, Fsm, ToolShed, _, StoryBook, out$ = typeof exports != 'undefined' && exports || this;
Url = require('url');
assert = require('assert');
less = require('less');
Session = require('./Session').Session;
ref$ = require('MachineShop'), Fsm = ref$.Fsm, ToolShed = ref$.ToolShed, _ = ref$._;
StoryBook = (function(superclass){
  var window, cE, aC, $, prototype = extend$((import$(StoryBook, superclass).displayName = 'StoryBook', StoryBook), superclass).prototype, constructor = StoryBook;
  function StoryBook(refs, id){
    var self, path, book, el_opts, this$ = this;
    self = this;
    if (typeof refs !== 'object') {
      this.debug.error("you need to pass a 'refs' object to the StoryBook");
    } else if (!refs.window) {
      throw new Error("for now, you MUST have a window for this book. later this will be relaxed bor servers and stuff... patience, dude");
    } else {
      this.refs = _.clone(refs);
    }
    window = refs.window;
    window.StoryBook = self;
    cE = window.cE;
    aC = window.aC;
    $ = window.$;
    path = Url.parse(window.location.href + '');
    this.path = this.initialPath = path.path;
    this.akaskic_records = this.library = refs.library;
    this.refs.book = refs.book = this;
    refs.session = this.session = new Session(refs, '1234');
    this.session.on('auth', function(){
      var i$, ref$, len$, poem, results$ = [];
      for (i$ = 0, len$ = (ref$ = self.poems).length; i$ < len$; ++i$) {
        poem = ref$[i$];
        results$.push(poem.exec('auth', self.session.current));
      }
      return results$;
    });
    this.session.on('noauth', function(){
      var i$, ref$, len$, poem, results$ = [];
      for (i$ = 0, len$ = (ref$ = self.poems).length; i$ < len$; ++i$) {
        poem = ref$[i$];
        results$.push(poem.exec('noauth'));
      }
      return results$;
    });
    book = this;
    this.session.on('mun', function(mun){
      if (this$.mun) {
        return this$.mun.exec('load', mun);
      } else {
        return this$.mun = this$.poetry.Word.Mun(mun);
      }
    });
    this.session.on('state:not_authenticated', function(){
      if (book.poem) {
        book.poem.exec('make_new');
        return book.poem.transition('/');
      }
    });
    this.session.on('state:authenticated', function(){
      var path, toState;
      path = Url.parse(window.location.href + '');
      toState = path.path !== this.path
        ? path.path
        : this.path;
      if (book.poem) {
        return book.poem.exec('load', book.session.persona);
      }
    });
    if (this.renderers) {
      this._renderers = this.renderers;
      delete this.renderers;
      this._parts = {};
    }
    this.books = {};
    this.poetry = {};
    this.memory = {};
    this.poems = [];
    this.poem = null;
    this.poem_els = [];
    this.poem_fqvns = [];
    this.words = {};
    this._ = {};
    if (typeof this._el === 'undefined') {
      this._el = 'div';
    }
    if (typeof this._el === 'string') {
      el_opts = this._class
        ? {
          c: this._class
        }
        : {};
      this._el = cE(this._el, el_opts);
    } else if (typeof this._el === 'function') {
      this._el = this._el.call(this, cE);
    } else if (typeof this._el !== 'object') {
      throw new Error("I dunno what to do! " + typeof this._el);
    }
    StoryBook.superclass.call(this, "StoryBook");
    if (typeof id === 'string') {
      this.debug.todo("load up a storybook from the database of a defined id (figurehead)");
    }
  }
  prototype.add_poetry = function(encantador, incantation, version, fn){
    if (typeof this.poetry[encantador] !== 'function') {
      throw new Error("you must make the encantador first ... not happens");
    }
    return this.poetry[encantador][incantation] = fn;
  };
  prototype.initialize = function(){
    return this.debug("storybook initialize!!!!!!");
  };
  prototype._class = 'StoryBook';
  prototype.renderers = ['poem_header', 'header', 'render', 'poem', 'footer', 'poem_footer'];
  prototype.elements = {
    Poem: {
      Affinaty: 'latest',
      Sandra: 'latest'
    }
  };
  prototype._render = function(){
    return this._el;
  };
  prototype.render = function(E){
    var s, ss;
    this.debug.error("whattt??? we shouldn't be here... remove me");
    if ((s = this.state) && (ss = this.states[s])) {
      if (ss instanceof Fsm) {
        return (function(){
          debugger;
        }());
      } else {
        return ss._el;
      }
    } else {
      return "yay!!!";
    }
  };
  prototype.eventListeners = {
    transition: function(e){
      var set_path, self, cE, aC, path, execs, this$ = this;
      set_path = 1;
      self = this;
      cE = self.refs.window.cE;
      aC = self.refs.window.aC;
      path = self.state;
      execs = Object.keys(this.states[e.toState]);
      _.each(this._derivitaves, function(v, derivitave){
        var d_name, i$, ref$, len$, exec, results$ = [];
        d_name = "derivitave." + derivitave;
        for (i$ = 0, len$ = (ref$ = execs).length; i$ < len$; ++i$) {
          exec = ref$[i$];
          if (exec === d_name) {
            results$.push(this$.exec(exec));
          }
        }
        return results$;
      });
      return _.each(self._renderers, function(renderer, i){
        var r, data, el;
        if (typeof self.state !== 'undefined') {
          if (typeof (r = self.states[path][renderer]) !== 'undefined') {
            data = e.args[0];
            if (typeof e.fromState === 'undefined') {
              aC(self._el, self._parts[renderer] = typeof r === 'function' ? r.call(self, cE, data) : r);
            } else if (el = self._parts[renderer]) {
              el.textContent = '';
              aC(el, typeof r === 'function' ? r.call(self, cE, data) : r);
            } else {
              set_path--;
            }
            if (path[0] === '/') {
              if (typeof e.fromState === 'string' && e.fromState[0] !== '/') {
                data = {
                  path: path,
                  mun: UniVerse.mun,
                  poem: UniVerse.poem
                };
                return this$.replace_path(data, "some title");
              } else if (set_path && data) {
                UniVerse.poem = data.poem;
                return this$.push_path(data, data.title + "");
              }
            }
          }
        }
      });
    },
    invalidstate: function(e){
      return this.debug.error("oh shit we're invalid (" + e.state + " -> " + e.attemptedState + ")");
    }
  };
  prototype.states = {
    uninitialized: {
      onenter: function(){
        return this.debug("StoryBook waiting for something to do...");
      },
      'derivitave.node-webkit': function(){
        var this$ = this;
        this.debug("doing uninitialized:node-webkit");
        process.removeAllListeners('uncaughtException');
        process.on('uncaughtException', function(err){
          console.error("uncaught error:", err.stack);
          throw err;
        });
      },
      'derivitave.browser': function(){
        var this$ = this;
        $(window).bind('click', function(e){
          var target, el, path, _path, machina;
          target = e.target;
          if (target.form) {
            e.preventDefault();
            return false;
          }
          if (e.metaKey || e.ctrlKey || e.shiftKey || e.defaltPrevented || (e.button && e.button !== 1) || typeof target.href === 'undefined') {
            return;
          }
          e.preventDefault();
          el = target;
          path = el.href;
          if (~path.indexOf('://')) {
            _path = Url.parse(path);
            path = _path.path;
          }
          do {
            if (machina = el._machina) {
              setTimeout(fn$, 100);
              e.stopImmediatePropagation();
              return false;
            }
          } while (el = el.parentNode);
          if (path) {
            this$.debug.error("wtf?!?! why?");
            return this$.route(path);
          }
          function fn$(){
            if (machina.states[machina.state][path]) {
              return machina.exec(path, e);
            } else {
              return machina.transition(path);
            }
          }
        });
        $(window).bind('popstate', function(evt){
          var url;
          if (url = evt.originalEvent.state) {
            this$.debug.todo("TODO!!!! - we really need a - back button! - lol");
            if (url) {
              this$.route(url.path, true);
            }
          } else {
            console.error("POP STATE");
          }
          evt.preventDefault();
        });
      },
      render: function(E){
        return E('div', null, "main...");
      }
    }
  };
  prototype.cmds = {
    login: function(opts, cb){
      throw new Error("not yet implemented dude");
      return this.session.exec('persona.login', function(opts, cb){});
    },
    logout: function(){
      return this.session.exec('persona.logout', function(){});
    },
    open: function(name, version, path, cb){
      var fqvn, this$ = this;
      if (typeof name !== 'string') {
        throw new Error("we can't figure out the name of the poetry you're trying to load");
      }
      if (typeof fqvn !== 'string') {
        fqvn = name;
      }
      return UniVerse.library.exec('fetch', {
        encantador: "Poem",
        incantation: name,
        version: version,
        book: this
      }, function(err, bp){
        return bp.once('state:ready', function(){
          this$.debug("POEM INITIALIZED.... wait for a session");
          return this$.session.once_initialized(function(){
            var noem, sess_id, poem, fqvn, not_found, i$, ref$, els, len$, e, parser;
            this$.debug("SESSION INITIALIZED....");
            noem = name + '@' + version;
            this$.debug.todo("replace_path here with the poem loaded ... later replace again");
            this$.session.now.poem = noem;
            sess_id = this$.session.id;
            this$.debug("loading poem '" + noem + "' with sess_id: " + sess_id, bp);
            this$.poem = poem = this$.poetry.Poem[name](sess_id);
            poem.on('transition', function(evt){
              if (evt.toState.indexOf('/') === 0) {
                this$.debug("set the path!! -> %s", evt.toState);
                return this$.push_path({
                  poem: poem.fqvn,
                  path: evt.toState
                }, poem.title);
              }
            });
            fqvn = name + '@' + version;
            this$.states[fqvn] = {};
            this$.states[fqvn].render = poem;
            this$.poems.push(poem);
            this$.poem_fqvns.push(fqvn);
            this$.poem_els.push(poem._el);
            if (!bp._blueprint.style) {
              debugger;
            } else {
              not_found = true;
              for (i$ = 0, len$ = (ref$ = els = document.getElementsByTagName('style')).length; i$ < len$; ++i$) {
                e = ref$[i$];
                if (e.dataset.encantador === bp.encantador && e.dataset.incantation === bp.incantation) {
                  not_found = e.disabled = false;
                } else {
                  e.disabled = true;
                }
              }
              if (not_found === true) {
                parser = new window.less.Parser({
                  env: 'development',
                  filename: bp.encantador + '-' + bp.incantation + '.less',
                  rootpath: window.location.host,
                  paths: ['bootstrap/less', '.'],
                  relativeUrls: false,
                  timeout: 2000
                });
                parser.parse(bp._blueprint.style, function(err, tree){
                  var css;
                  css = tree.toCSS();
                  return aC(null, cE('style', {
                    data: {
                      encantador: bp.encantador,
                      incantation: bp.incantation
                    }
                  }, css));
                }, {
                  globalVars: void 8,
                  modifyVars: void 8
                });
              }
            }
            poem.transition(this$.path);
            this$.transition(noem);
            this$.debug.todo("load up the path into the poem");
          });
        });
      });
    },
    activate: function(fqvn){
      throw new Error("not yet implemented - poem switching");
      return (function(){
        debugger;
      }());
    }
  };
  Object.defineProperty(prototype, 'authenticated', {
    get: function(){
      if (this.session.current) {
        return true;
      } else {
        return false;
      }
    },
    configurable: true,
    enumerable: true
  });
  prototype.replace_path = function(data, title){
    return window.history.replaceState(data, title, data.path);
  };
  prototype.push_path = function(data, title){
    return window.history.pushState(data, title + Math.random().toString(32).slice(2), data.path);
  };
  prototype.route = function(path, is_back){
    var window_href, window_href_base, mun, poem, url, proto, querystring, i, lala, this$ = this;
    window_href = window.location.href + '';
    window_href_base = window_href.substr(0, window_href.lastIndexOf('/'));
    mun = this.session.current ? this.session.current.mun : null;
    poem = this.state;
    url = Url.parse(path);
    if (url.path) {
      path = url.path;
    }
    if (url.protocol) {
      proto = url.protocol;
    }
    querystring = '';
    if (i = ~path.indexOf('?')) {
      querystring = path.slice(i + 1);
      path = path.slice(0, i);
    }
    this.debug("route:", path, "->", this.path);
    if (path !== this.path) {
      poem = this.states[this.state].render;
      poem.transition(path, {
        poem: poem,
        path: path,
        mun: mun
      });
    }
    switch (proto) {
    case 'poem':
      this.debug.error("poem router... eventually this will become a its own poem ... eg. poem://saviour/emanuel/muthta/fuckin/christ/is/awesome will oviously route 'emanuel/muthta/fuckin/christ/is/awesome' inside of the 'saviour' poem - obviously :) lol");
      debugger;
      this.debug(" " + proto + ":" + poem + " @ path: " + path);
    }
    switch (path) {
    case '/logout':
      this.exec('logout');
      break;
    case '/disconnected':
      refs.poem.emit('disconnected');
      aC(null, lala = cE('div', {
        c: 'modal-backdrop fade in'
      }));
      _universe.on('ready', function(){
        return $(lala).remove();
      });
    }
    return this.debug("we're done routing now ... is_back: %s", is_back);
  };
  return StoryBook;
}(Fsm));
ToolShed.extend(StoryBook.prototype, Fsm.Empathy);
out$.StoryBook = StoryBook;
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}