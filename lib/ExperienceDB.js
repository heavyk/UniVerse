// Generated by LiveScript 1.2.0
var Http, assert, ref$, Fsm, ToolShed, _, ExperienceDB, parse_parens, Quest, Perspective, out$ = typeof exports != 'undefined' && exports || this;
Http = require('http');
assert = require('assert');
ref$ = require('MachineShop'), Fsm = ref$.Fsm, ToolShed = ref$.ToolShed, _ = ref$._;
ExperienceDB = (function(superclass){
  var prototype = extend$((import$(ExperienceDB, superclass).displayName = 'ExperienceDB', ExperienceDB), superclass).prototype, constructor = ExperienceDB;
  function ExperienceDB(incantation){
    this.incantation = incantation;
    this._ = [];
    this._indices = {};
    this._idx = {};
    this.__request = [];
    if (assert) {
      this.deleted = [];
    }
    ExperienceDB.superclass.call(this, "ExperienceDB(" + incantation + ")");
  }
  prototype.states = {
    uninitialized: {
      onenter: function(){
        return console.log("we're gonna connect now...");
      }
    },
    connected: {
      onenter: function(){
        return console.log("connected to the database now..");
      }
    },
    disconnected: {
      onenter: function(){
        return console.log("disconnected from the universe");
      }
    }
  };
  prototype.eventListeners = {
    found: function(key, xp){
      return this.emit("found:" + key, xp);
    },
    changed: function(key, xp, old_xp, diff){
      return this.emit("changed:" + key, xp, old_xp, diff);
    },
    forgotten: function(key, xp){
      var k, ref$, ref1$;
      k = "forgotten:key";
      this.emit(k, xp);
      return ref1$ = (ref$ = this.eventListeners)[k], delete ref$[k], ref1$;
    },
    error: function(key, err){
      if (key) {
        return this.emit("error:" + key, err);
      }
    }
  };
  prototype._set = function(key, rev, xp){
    var i$, ref$, len$, i, _xp;
    for (i$ = 0, len$ = (ref$ = this._).length; i$ < len$; ++i$) {
      i = i$;
      _xp = ref$[i$];
      if (_xp._key === key) {
        if (rev) {
          if (_xp._rev === rev) {
            this._.splice(i, 1, xp);
            return _xp;
          }
        } else {
          this._.splice(i, 1, xp);
          return _xp;
        }
      }
    }
    this._.push(xp);
    return false;
  };
  prototype._del = function(key, rev){
    var i$, ref$, len$, i, _xp;
    for (i$ = 0, len$ = (ref$ = this._).length; i$ < len$; ++i$) {
      i = i$;
      _xp = ref$[i$];
      if (_xp._key === key) {
        if (rev) {
          if (_xp._rev === rev) {
            this._.splice(i, 1);
            return _xp;
          }
        } else {
          this._.splice(i, 1);
          return _xp;
        }
      }
    }
    return null;
  };
  prototype._get = function(key, rev){
    var i, ii, i$, ref$, len$, xp;
    if (this._idx && typeof (i = this._idx[key]) !== 'undefined') {
      if (Array.isArray(ii = this._[i])) {
        return ii[0];
      } else {
        return ii;
      }
    }
    for (i$ = 0, len$ = (ref$ = this._).length; i$ < len$; ++i$) {
      xp = ref$[i$];
      if (xp._key === key) {
        if (rev) {
          if (xp._rev === rev) {
            return xp;
          }
        } else {
          return xp;
        }
      }
    }
    return null;
  };
  prototype._req = function(method, key, vals, cb){
    var id, opts, req, req_txt, this$ = this;
    id = this.incantation;
    if (key) {
      if (assert && method === 'delete') {
        if (~this.deleted.indexOf(key)) {
          console.log("this shouldn't happen... kinda an insurance policy while testing");
          debugger;
        } else {
          this.deleted.push(key);
        }
      }
      id += "/" + key;
      if (this.__request[key]) {
        console.log("already saving... throttle this");
        console.log("TODO: add 'saving' 'saved' 'save_timeout' events plus debounce with a cooldown to try again");
        this.debug.todo("re-request in x time");
        debugger;
      }
    }
    opts = {
      method: method,
      path: "/db/" + id
    };
    console.log("sending req:", opts);
    req = Http.request(opts, function(res){
      var data;
      res.on('error', function(err){
        var idx;
        if (key) {
          delete this.__request[key];
        } else if (~(idx = this.__request.indexOf(req))) {
          this.__request.splice(idx, 1);
        } else {
          this.debug.error("unknown request!");
        }
        this.emit("error:" + key, err);
        debugger;
        return console.error("we've got an error!!", err);
      });
      data = '';
      res.on('data', function(buf){
        if (buf) {
          return data += buf;
        }
      });
      res.on('end', function(){
        var xp, code;
        console.log("done with the request:", method, id);
        this$.__request[key] = null;
        if (res.statusCode === 200) {
          if (method !== 'delete') {
            xp = ToolShed.objectify(data, {}, {
              name: id
            });
            if (xp._key && !xp._id) {
              xp._id = this$.incantation + '/' + xp._key;
            }
            if (typeof cb === 'function') {
              return cb(null, xp);
            }
          } else if (typeof cb === 'function') {
            return cb(null, key);
          }
        } else {
          code = res.statusCode;
          if (code === 404) {
            code = 'ENOENT';
          } else {
            debugger;
          }
          this$.emit("error:" + key, {
            code: code
          });
          if (typeof cb === 'function') {
            return cb({
              code: code
            }, key);
          }
        }
      });
    });
    if (key) {
      this.__request[key] = req;
    } else {
      this.__request.push(req);
    }
    if (vals) {
      req.write(req_txt = JSON.stringify(vals));
    }
    return req.end();
  };
  prototype.get = function(key, rev, cb){
    var this$ = this;
    if (typeof rev === 'function') {
      cb = rev;
      rev = void 8;
    }
    this._req('get', key, null, function(err, xp){
      if (!err) {
        this$.emit('found', key, xp);
      }
      if (typeof cb === 'function') {
        cb(err, xp);
      }
    });
    return this._get(key);
  };
  prototype.patch = function(key, rev, xp, cb){
    var _xp, this$ = this;
    if (typeof rev === 'object') {
      cb = xp;
      xp = rev;
      rev = void 8;
    }
    this._req('patch', key, xp, cb);
    if (!(_xp = this._get(key, rev))) {
      this.debug.error("dude you're trying to patch something that doesn't exist");
      return false;
    }
    import$(_xp, xp);
    this._req('patch', null, _xp, function(err, xp){
      if (err) {
        this$._set(key, null, _xp);
        this$.emit('changed', key, _xp);
        this$.emit('error', err);
      }
    });
    this.emit('changed', key, _xp);
    return _xp;
  };
  prototype.create = function(xp, cb){
    var vals, key, this$ = this;
    vals = ToolShed.extend({}, xp);
    assert(typeof vals._rev === 'undefined');
    assert(typeof vals._id === 'undefined');
    assert(typeof vals._key === 'undefined');
    assert(typeof vals._k === 'undefined');
    this._req('post', null, vals, function(err, _xp){
      _xp = import$(xp, _xp);
      this$.emit('changed', xp._k, _xp);
      this$._set(key, null, _xp);
      if (typeof cb === 'function') {
        cb.apply(this$, arguments);
      }
    });
    key = xp._k;
    xp._key = xp._k = key;
    xp._id = this.incantation + '/' + key;
    this.emit('found', key, xp);
    this._set(key, null, xp);
    return xp;
  };
  prototype.forget = function(key, cb){
    var xp, this$ = this;
    xp = this._get(key);
    this.emit('forgotten', key);
    return this._req('delete', key, null, function(err){
      if (err) {
        this$.emit('error', err);
        this$.emit('found', key, vals);
        if (typeof cb === 'function') {
          cb.apply(this$, arguments);
        }
      }
    });
  };
  constructor._ = {};
  return ExperienceDB;
}(Fsm));
parse_parens = function(txt){
  var p, i, q1, q2, len, c, idx;
  throw new Error("we don't support paren parsing yet");
  p = i = q1 = q2 = 0;
  len = txt.length;
  while (i < len) {
    c = txt[i++];
    switch (c) {
    case '(':
      p++;
      break;
    case ')':
      p--;
      break;
    case '\'':
      if (q1) {
        q1--;
      } else {
        q1 === 0 && q1++;
      }
      break;
    case '"':
      if (q2) {
        q2--;
      } else {
        q2 === 0 && q2++;
      }
    }
  }
  if (~(idx = txt.indexOf(')'))) {
    return txt.substr(0, idx);
  }
  return '';
};
Quest = (function(superclass){
  var prototype = extend$((import$(Quest, superclass).displayName = 'Quest', Quest), superclass).prototype, constructor = Quest;
  function Quest(_bp, key, opts){
    var _q;
    this._bp = _bp;
    this.key = key;
    this.book = _bp.refs.book;
    this.quest = _q = _bp._blueprint.quests[key];
    if (typeof opts !== 'object') {
      opts = {};
    }
    delete opts.quest;
    this.opts = opts;
    this.keys = [];
    this._window = 10;
    if (_q) {
      this.initialState = 'quest';
    } else {
      this.initialState = 'ENOQUEST';
    }
    Quest.superclass.call(this, _bp.incantation + ":Quest(" + key + ")");
  }
  prototype._filter_fn = null;
  prototype._inquire = function(inquiry, depth){
    var scope, js, ii, i, v, vi, joined, multi_filter, vars, vp, is_or, is_and, done, l, expr, r, rr, this$ = this;
    if (typeof depth === 'undefined') {
      depth = 0;
      scope = {};
      js = "";
    }
    ii = inquiry.split(/[\n\t ]+/);
    while (ii && (i = ii.shift())) {
      switch (i.toUpperCase()) {
      case 'FOR':
        v = ii.shift();
        if (v.charAt(0) === '_') {
          throw new Error("AQL does not allow any collections to start with '_'");
        }
        break;
      case 'IN':
        vi = ii.shift();
        if (vi.charAt(0) === '_') {
          throw new Error("AQL does not allow any vars to start with '_'");
        }
        js += "this['" + v + "'] = [];\n";
        if (Array.isArray(ExperienceDB._[vi])) {
          js += "_.each(this._['" + vi + "'], function(" + v + "){\n";
        }
        break;
      case 'FILTER':
        if (ii[0].charAt(0) === '(') {
          console.log("quickly parse the parens using a loop, then parse the expression into a function");
          joined = ii.join(' ');
          console.log("this expression: '%s'", joined);
          throw new Error("filters with expressions not yet supported. we accept pull requests :)");
          multi_filter = true;
          vars = [vv.substr(1)];
          while (vp = ii.shift()) {
            switch (vp.toUpperCase()) {
            case '||':
              is_or = true;
              break;
            case '&&':
              is_and = true;
              break;
            default:
              if (vp.substr(-1) === ')') {
                done = true;
              }
            }
          }
        }
        break;
      case 'LET':
        throw new Error("we don't support expressions quite yet");
        l = ii.shift();
        expr = ii.join(' ');
        js += "this['" + l + "'] = function() {}";
        break;
      case 'SORT':
        throw new Error("we don't support sorted things ...yet");
      case 'LIMIT':
        throw new Error("we don't support limits yet");
      case 'RETURN':
        r = ii.shift();
        r = ii.join(' ');
        rr = r.split('.');
        js += "this['" + v + "'].push(" + r + ")";
        ii = null;
      }
    }
    this.book.memory[vi].on('forgotten', function(key, xp){
      var idx;
      console.log("forgot exp", key);
      if (~(idx = this$.keys.indexOf(key))) {
        this$.emit('removedAt', key, idx);
        if (this$.keys.length < this$._window) {
          return this$;
        }
      }
    });
    this.book.memory[vi].on('found', function(key, xp){
      console.log("we found xp", xp, this$.keys.indexOf(key));
      if (!~this$.keys.indexOf(key)) {
        return this$.emit('addedAt', key, 0);
      }
    });
    return new Function(js);
  };
  prototype.inquire = function(inquiry){
    return this.filter_fn = this._inquire(inquiry);
  };
  prototype.eventListeners = {
    added: function(key){
      return this.keys.push(key);
    },
    addedAt: function(key, i){
      return this.keys.splice(i, 0, key);
    },
    removed: function(key){
      var ref$;
      if (key) {
        assert((ref$ = this.keys)[ref$.length - 1] === key);
      }
      return this.keys.pop();
    },
    removedAt: function(key, i){
      if (key) {
        assert(this.keys[i] === key);
      }
      return this.keys.splice(i, 1);
    }
  };
  prototype.states = {
    uninitialized: {
      onenter: function(){}
    },
    ENOENT: {
      onenter: function(){
        this.debug.error("lol, this quest doesn't exist");
        return this.debug.todo("overrite this with a word called QuestCreator\nthis should be an abstract object too, which then takes care of everything");
      }
    },
    quest: {
      onenter: function(){
        var opts;
        if (this.__loading) {
          this.__loading.abort();
        }
        opts = import$({
          quest: this.key
        }, this.opts);
        this.inquire(this.quest.inquiry);
        this.emit('questing', this.key);
        return this.exec('request', opts);
      },
      more_quest: function(opts){
        if (!this._id) {
          debugger;
          this.debug.error("nothing more to quest!");
          return;
        }
        if (typeof opts === 'nubmer') {
          opts = {
            many: opts
          };
        } else if (typeof opts !== 'object') {
          opts = {};
        }
        opts.cursor = this._id;
        return this.exec('request', opts);
      },
      request: function(opts){
        var req_txt, bp, req, this$ = this;
        req_txt = JSON.stringify(opts);
        bp = this._bp;
        this.__loading = req = Http.request({
          method: 'post',
          path: "/db/_/" + bp.encantador + ":" + bp.incantation + "@" + bp.version + "/"
        }, function(res){
          var data;
          res.on('error', function(err){
            this$.__loading = null;
            switch (err.code) {
            case 'ENOENT':
              this$.debug.error("blueprint does not exist...");
              break;
            case 'ENOQUESTS':
              this$.debug.error("blueprint does not have any quests");
              break;
            case 'ENOQUEST':
              this$.debug.error("blueprint does not have any have this quest");
              break;
            default:
              this$.debug.error("we've got an error!!");
            }
            return this$.transition(err.code);
          });
          data = '';
          res.on('data', function(buf){
            return data += buf;
          });
          return res.on('end', function(){
            var json, result, i$, len$, i, key;
            console.log("this is the result of loading a quest: (" + this$.key + "):", res.statusCode);
            this$._loading = null;
            if (!opts.cursor) {
              this$.emit('empty');
            }
            if (res.statusCode === 200) {
              if (typeof data === 'string' && data[0] === '{') {
                json = JSON.parse(data);
                this$._more = json.hasMore;
                setTimeout(function(){
                  this$.debug("resetting more_quest cursor ... prolly doesn't exist now");
                  return this$._id = 0;
                }, 20000);
                if (!this$._id) {
                  this$._id = json.id;
                  this$.total = json.count;
                }
                if (Array.isArray(result = json.result)) {
                  console.log("results:", result);
                  if (result.length === 0) {
                    this$.emit('nada');
                  }
                  for (i$ = 0, len$ = result.length; i$ < len$; ++i$) {
                    i = i$;
                    key = result[i$];
                    this$.emit('added', key);
                  }
                  this$.emit('more', json.count - result.length);
                  assert(json.count >= result.length);
                } else {
                  this$.emit('nada');
                }
              } else if (typeof data === 'undefined') {
                this$.emit('empty');
              }
            } else {
              this$.emit('error', {
                code: 'ENOENT'
              });
              this$.transition(res.statusCode);
            }
            if (this$._more && this$.keys.length < this$._window * 1.5) {
              return this$.exec('more_quest');
            }
          });
        });
        req.on('error', function(err){
          debugger;
          console.error("(re)quest error", err);
          return this$.emit('error');
        });
        req.write(req_txt);
        return req.end();
      }
    }
  };
  return Quest;
}(Fsm));
Perspective = (function(superclass){
  var prototype = extend$((import$(Perspective, superclass).displayName = 'Perspective', Perspective), superclass).prototype, constructor = Perspective;
  function Perspective(incantation){
    this.incantation = incantation;
    this._ = {};
    Perspective.superclass.call(this, "Perspective(" + incantation + ")");
  }
  prototype.eventListeners = {
    visible: function(incantation, key, rev){
      return this.debug.todo("get the updates to this element and then emit them");
    }
  };
  prototype.states = {
    connected: {
      onenter: function(){
        this.debug("yay!! we're connected");
        return this.debug.todo("begin listening to events again on all experiences in the perspective");
      },
      visible: function(incantation, key, rev){
        return this.debug.todo("get the updates to this experience and then emit them");
      },
      invisible: function(incantation, key, rev){
        return this.debug.todo("stop listining to the updates on this eexperience");
      }
    },
    disconnected: {
      onenter: function(){
        return this.debug("booo... we've been disconnected");
      }
    }
  };
  return Perspective;
}(Fsm));
out$.ExperienceDB = ExperienceDB;
out$.Quest = Quest;
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}