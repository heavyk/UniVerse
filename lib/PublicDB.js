// Generated by LiveScript 1.2.0
var Path, Fs, Url, Http, ref$, Fsm, ToolShed, _, Debug, debug, get_path, set_path, Blueprint, levelJs, LocalDB, PublicDB, out$ = typeof exports != 'undefined' && exports || this;
Path = require('path');
Fs = require('fs');
Url = require('url');
Http = require('http');
ref$ = require('MachineShop'), Fsm = ref$.Fsm, ToolShed = ref$.ToolShed, _ = ref$._;
Debug = ToolShed.Debug;
debug = Debug('PublicDB');
/**
PubliCDB

TODO: go ahead and add redis
TODO: add redis scripts: https://www.npmjs.org/package/libris

Basically it goes like this...

 - PublicDB is a replicatable, persistent, distributed database
 - Blueprint is sorta like the Schema
 - Word is sorta like the model
	- I think I need to change to Syllable
*/
/*
export Blueprint = (opts, refs) ->
	debug = Debug "Blueprint"
	opts = {} unless typeof opts is \object
	refs = {} unless typeof refs is \object

	unless opts.name or opts.name is \undefined
		throw new Error "you gatta have a collection name"

	unless db = refs.db
		db = PublicDB {}

	collection_name = opts.collection or opts.name # Mongoose.utils.toCollectionName opts.name

	if bp = db._blueprints[opts.name]
		return bp

	unless blueprint = bp._blueprint || opts.blueprint
		throw new Error "blueprint not defined"

	bp = new Fsm "Blueprint(#{opts.name})" {
		name: opts.name
		opts: opts
		refs: refs
		path: collection_path = Path.join db.path, collection_name
		blueprint_path: blueprint_path = Path.join db.path, opts.name+'.blueprint.json'
		queries: []
		__blueprint: {}

		blueprint: (blueprint, options) ->
			if @state is \config
				@config.blueprint = blueprint
				@transition \blueprint
			else @until \ready, ~>
				# XXX: do some cleaning on the input... only get the required stuff
				#  make sure to set the options as well.
				#  actually, I probably should merge the two objects, then new Schema [merged]
				#  then, after mongoose has done the work for me, update the local variables in @blueprint

				# XXX: after all of the blueprints are loaded, then if they still don't match
				#  that perhaps means that something needs to be deleted...
				#  figure out how to do that

				# XXX: optimize me a bit here :)
				unless @config.blueprint
					@config.blueprint = {}
				_.merge @__blueprint, blueprint
				json1 = ToolShed.stringify(@config.blueprint)
				json2 = ToolShed.stringify(@__blueprint)
				if json1 isnt json2
				# this doesn't work because of the super way the config works...
				# I probably need to improve it
				#unless _.isEqual @config.blueprint, @__blueprint
					_.merge @config.blueprint, @__blueprint
					@config.once \save (obj, path) ->
						console.log "saved", path #, json1 is json2

		find: (conditions, fields, options, callback) ->
			# XXX: this will break if you provide a callback
			# XXX: this should be abstracted for all operations!
			if @state isnt \ready
				console.log "no good!!!"
				return
				q = new Mongoose.Query conditions, options
				p = new Mongoose.Promise
				exec = q.exec
				q.exec = (cb) ->
					p.addBack cb
				@once \ready, ~>
					q.bind @_blueprint, 'find'
					q.select fields if fields
					pp = exec.call q
					pp.addBack p.resolve.bind p
					q.exec = exec
				return q
			else bp._blueprint.find.apply bp._blueprint, &

		count: (conditions, callback) ->
			if typeof conditions is \function
				callback = conditions
				conditions = {}

			if @state isnt \ready
				# XXX: this isn't actually tested, because I always do a count after I do a find.
				#   this means, that the blueprint is always ready. so this case is never entered
				q = new Mongoose.Query conditions

				@once \ready, ~>
					q.bind bp._blueprint, 'count'
					q.count.call q, callback
				return q
			else
				bp._blueprint.count.apply bp._blueprint, &

		states:
			uninitialized:
				onenter: ->
					ToolShed.mkdir collection_path, (err, dir) ->
						if err
							bp.emit \error, err
							bp.transition \error
						else bp.transition \config

			config:
				onenter: ->
					bp.config = ToolShed.Config blueprint_path
					bp.config.on \ready (err, p) ->
						#unless err
						bp.transition \blueprint

			blueprint:
				onenter: ->
					arango = db
					if opts.blueprint
						# it'll probably never get here, because I'm instantiating from db.blueprints[...] instead of calling the function
						console.log "blueprint update??", opts.blueprint

					console.log "config.blueprint", bp.config.blueprint
					bp._blueprint = Schema bp.config.blueprint
					# IMPROVEMENT: make the plugins dynamic!
					# eg. for plugin in bp.layout.plugins => bp._blueprint.plugin require plugin
					# IMPROVEMENT: save the index into the blueprint as well
					bp._blueprint.plugin require 'mongoose-text-search'
					bp._blueprint.plugin require 'mongoose-lifecycle'
					unless bp.config.blueprint?created
						bp._blueprint.plugin require 'mongoose-troop/lib/timestamp'
					if bp.config.blueprint?tags
						bp._blueprint.index tags: \text
					console.log "blueprint", collection_name, bp._blueprint
					bp._blueprint = Model collection_name, bp._blueprint
					bp._blueprint.on \afterSave (doc) ->
						setTimeout ->
							console.log "saved a blueprint", doc
							for q in bp.queries
								# OPTIMIZE: analyze to see if it's possible that we actually need to re-run the query here
								# for now thouh, we're gonna burn those cpu cycles. me la suda
								q.emit \run
						, 200ms
					bp._blueprint.on \afterRemove (doc) ~>
						process.nextTick ->
							for q in bp.queries
								rm = false
								for d, i in q._docs
									if d._id.toHexString! is doc._id.toHexString!
										q.emit \removedAt d, i
										rm = i
										break
								if rm isnt false
									# XXX if the count was the limit, rerun the query
									if q._docs.length is q.q.options.limit
										q.emitSoon \run
									q._docs.splice rm, 1
					#bp._blueprint.on \afterUpdate (doc) ->
					console.log "waiting for db to become ready", opts.name
					db.until \ready ->
						console.log
						bp.transition \populate

			populate:
				onenter: ->
					insert_doc = (id, path, done) ->
						bp._blueprint.findById id, (err, doc) ->
							if doc => done null
							else Fs.readFile path, 'utf-8', (err, data) ->
								try
									if err => done err
									else
										bp._blueprint.create JSON.parse(data), done
								catch e
									done e
					Fs.stat collection_path, (err, dir_st) ->
						if err
							bp.emit \error, err
							bp.transition \uninitialized
						else
							task = bp.task "populate Blueprint(#{collection_name})"
							debug "walking: %s", collection_path
							walker = Walk collection_path, max_depth: 1
							walker.on \file (path, st) ->
								if (st - dir_st) > 0 or opts.populate or true
									# HERE: I think the above comparison is wrong!
									# I need to check to see if it's greater than the bp.layout.mtime
									# then, I need to check to see if the id exists in the database (in update mode)
									file = Path.basename path
									file.replace /^[0-9a-f]{24}/, (id) ->
										if id => task.push (done) -> insert_doc id, path, done
							walker.on \error (err) ->
								console.log "walker encountered an error", err
								bp.emit \error err
								bp.transition \error
							walker.on \end ->
								if task.fns.length
									task.end (err, res) ->
										if err
											bp.emit \error err
											bp.transition \error
										else bp.transition \ready
								else bp.transition \ready
							if opts.watch
								console.log "not yet implemented, sorry"
								#Fs.watch

			ready:
				onenter: ->
					bp.emit \ready

				dump: ->
					task = bp.task "dumping collection #{collection_name}"
					stream = bp._blueprint.find!lean!stream!
					task.push (done) ->
						stream.on \error done
						stream.on \close done
					stream.on \data (doc) ->
						task.push (done) ->
							ToolShed.writeFile Path.join(collection_path, doc._id+'.json'), ToolShed.stringify(doc, null, "\t"), done
					task.end (err, res) ->
						if err
							bp.emit \dump_failed, err
						else bp.emit \dump_complete

	}
*/
get_path = function(obj, str){
  var i;
  str = str.split('.');
  i = 0;
  while (i < str.length) {
    obj = obj[str[i++]];
  }
  return obj;
};
set_path = function(obj, str, val){
  str = str.split('.');
  while (str.length > 1) {
    obj = obj[str.shift()];
  }
  return obj[str.shift()] = val;
};
out$.Blueprint = Blueprint = function(refs, opts){
  var incantation, i, encantador, version, _version, long_incantation, bp, window, $, get_bp, machina;
  if (typeof opts === 'string') {
    incantation = opts;
    if (~(i = incantation.indexOf(':'))) {
      encantador = incantation.substr(0, i);
      incantation = incantation.substr(i + 1);
      if (~(i = incantation.indexOf('@'))) {
        version = incantation.substr(i + 1);
        incantation = incantation.substr(0, i);
      }
    }
    opts = {
      encantador: encantador,
      incantation: incantation,
      version: version
    };
  } else if (typeof opts === 'object') {
    encantador = opts.encantador;
    incantation = opts.incantation;
    version = opts.version;
  }
  if (!incantation) {
    console.error("you need a incantation for your blueprint!");
    throw new Error("you need a incantation for your blueprint!");
  }
  if (!encantador) {
    console.error("you need a encantador for your blueprint!");
    throw new Error("you need a encantador for your blueprint!");
  }
  if (typeof version === 'object') {
    _version = version;
    version = version.version;
  }
  if (!version || version === '*') {
    version = 'latest';
  }
  long_incantation = encantador + ':' + incantation + '@' + version;
  if (bp = Blueprint._[long_incantation] && typeof DEBUG !== 'undefined') {
    return bp;
  }
  window = refs.window;
  $ = window.$;
  if (typeof UniVerse._[encantador] !== 'object') {
    UniVerse._[encantador] = {};
  }
  if (typeof UniVerse._[encantador][version] !== 'object') {
    UniVerse._[encantador][version] = {};
  }
  get_bp = function(encantador, incantation, version, cb){
    return $.ajax({
      url: "/db/_bp/" + encantador + "/" + incantation,
      type: 'get',
      dataType: 'json',
      context: this,
      data: version && version !== 'latest' ? $.param({
        version: version
      }) : void 8,
      success: function(res){
        if (typeof cb === 'function') {
          return cb(void 8, res);
        }
      },
      error: function(err){
        if (typeof cb === 'function') {
          return cb(err);
        }
      }
    });
  };
  Blueprint._[long_incantation] = machina = new Fsm("Blueprint(" + long_incantation + ")", {
    refs: refs,
    renderers: ['header', 'render', 'footer'],
    incantation: incantation,
    fqvn: long_incantation,
    encantador: encantador,
    version: version,
    inst: function(key){
      var element, id, lala;
      console.log("instatantiate " + encantador + "(" + key + ")");
      if (key && (element = UniVerse._[machina.encantador][version][id = machina.incantation + '/' + key])) {
        return element;
      } else {
        console.error("inst:", machina.encantador, version, id, machina);
        eval("(function(){\n	archive.blueprints['" + machina.encantador + "'] = " + machina.encantador + " = (function(superclass){\n		var prototype = extend$((import$(" + machina.encantador + ", superclass).displayName = '" + machina.encantador + "', " + machina.encantador + "), superclass).prototype, constructor = " + machina.encantador + ";\n		ToolShed.extend(prototype, machina._blueprint.machina);\n		function " + machina.encantador + "(_bp, key){\n			" + machina.encantador + ".superclass.call(this, _bp, key);\n		}\n		return " + machina.encantador + ";\n	}(Meaning));\n	element = new " + machina.encantador + "(machina, key);\n}())");
        console.log("going to extend element", element, "with", machina._blueprint.machina);
        if (machina.incantation === 'Mun') {
          debugger;
        }
        console.log("before funkify:", lala);
        if (machina.incantation === 'Mun') {
          debugger;
        }
        lala = ToolShed.da_funk(lala, {
          lala: 1234
        }, {
          name: machina.fqvn
        });
        console.log("after funkify:", lala);
        if (machina.incantation === 'Mun') {
          debugger;
        }
        return UniVerse._[machina.encantador][version][id] = lala;
      }
    },
    states: {
      uninitialized: {
        onenter: function(){
          return get_bp(encantador, incantation, version, function(err, res){
            var _bp, deps, task;
            if (err) {
              machina.emit('error', err);
              return machina.transition('error');
            } else {
              machina._blueprint = _bp = import$({}, res);
              console.error("objectify res:", res, _bp);
              machina.layout = res.layout || {};
              deps = ToolShed.embody({}, res.elements);
              task = machina.task("get deps for " + long_incantation);
              console.warn(long_incantation, "DEPS: ", deps);
              _.each(deps, function(deps, encantador){
                return _.each(deps, function(version, incantation){
                  return task.push(function(done){
                    var bp;
                    if (typeof UniVerse.poetry[encantador] === 'undefined') {
                      UniVerse.poetry[encantador] = {};
                    }
                    console.log("poetry", UniVerse.poetry);
                    if (!(bp = UniVerse.poetry[encantador][incantation])) {
                      UniVerse.poetry[encantador][incantation] = bp = UniVerse.storage.get(encantador, incantation, version);
                    }
                    if (bp.state === void 8) {
                      return bp.once_initialized(function(){
                        console.warn(long_incantation, "READY:dep:", encantador, incantation, version, machina.state);
                        return done();
                      });
                    } else {
                      return done();
                    }
                  });
                });
              });
              return task.end(function(err, res){
                console.log("DEPS done: " + long_incantation);
                console.info("initialized blueprint", machina.fqvn);
                return this.transitionSoon('ready');
              });
            }
          });
        }
      },
      ready: {
        onenter: function(){
          console.log("blueprint ready", incantation, machina);
          return this.emit('ready');
        },
        verify: function(path, val){}
      },
      error: {
        onenter: function(){
          return console.error("you have tried to load a blueprint which wasn't able to be fetched", incantation);
        }
      }
    }
  });
  return machina;
};
Blueprint._ = {};
Blueprint._db_refs = {};
Blueprint.db_ref = function(name, host){
  Blueprint._db_refs[name] = host;
  if (!Blueprint._db_default) {
    return Blueprint._db_default = name;
  }
};
Blueprint.db_default = function(db){
  return Blueprint._db_default = db;
};
levelJs = require('level-js');
out$.LocalDB = LocalDB = (function(superclass){
  var i$, ref$, len$, k, prototype = extend$((import$(LocalDB, superclass).displayName = 'LocalDB', LocalDB), superclass).prototype, constructor = LocalDB;
  function LocalDB(options){
    var name;
    console.log("options", options);
    if (!(name = options.name)) {
      throw new Error("you must provide a 'name' for your LocalDB");
    }
    this.storage = levelJs(name);
    LocalDB.superclass.call(this, "LocalDB");
  }
  prototype.states = {
    uninitialized: {
      onenter: function(){
        var this$ = this;
        return this.storage.open(function(err){
          if (err) {
            return this$.transition('error');
          } else {
            return this$.transition('ready');
          }
        });
      }
    },
    ready: {
      onenter: function(){
        return this.emit('ready');
      }
    },
    error: {
      onenter: function(){
        return this.emit('error');
      }
    }
  };
  for (i$ = 0, len$ = (ref$ = ['get', 'set', 'remove', 'list', 'clear']).length; i$ < len$; ++i$) {
    k = ref$[i$];
    constructor.prototype[k] = fn$(k);
  }
  constructor.prototype.query = function(query){
    return console.log("TODO: query the LocalDB/PubliCDB");
  };
  return LocalDB;
  function fn$(k){
    return function(key, options, cb){
      var dfd;
      if (this.state === 'error') {
        if (typeof cb === 'function') {
          return cb({
            code: 'ERRNOTAVAILABLE'
          });
        }
      } else {
        dfd = this.storage[k].call(this.storage, key, options);
        if (typeof cb === 'function') {
          dfd.then(cb);
        }
        return dfd;
      }
    };
  }
}(Fsm));
out$.PublicDB = PublicDB = function(opts, db_ready){
  var debug, name, db, self, db_path;
  debug = Debug("PublicDB");
  if (typeof opts === 'string') {
    opts = {
      name: opts
    };
  } else if (typeof opts !== 'object') {
    opts = {};
  }
  if (!(name = opts.name)) {
    console.error("you need a name for your database!");
    throw new Error("you need a 'name' for your database");
  }
  if (db = PublicDB.dbs[opts.name]) {
    return db;
  }
  if (!opts.host) {
    opts.host = '127.0.0.1';
  }
  if (!opts.port) {
    opts.port = 8529;
  }
  self = PublicDB.dbs[opts.name] = new Fsm("PublicDB(" + opts.name + ")", {
    name: opts.name,
    opts: opts,
    path: db_path = Path.join('db', opts.name),
    get: function(encantador, incantation, version, opts){
      var i, long_incantation, bp, task;
      console.log("PublicDB.get", arguments);
      if (typeof version === 'object') {
        opts = version;
        version = opts.version;
      }
      if (!version) {
        version = 'latest';
      }
      throw new Error(" don't use this for now ... use PoetryBook.get");
      if (~(i = incantation.indexOf('@'))) {
        version = incantation.substr(i + 1);
        incantation = incantation.substr(0, i);
      }
      long_incantation = encantador + ':' + incantation + '@' + version;
      if (typeof (bp = Blueprint._[long_incantation]) === 'undefined') {
        console.log("new Blueprint");
        bp = new Blueprint(refs, {
          encantador: encantador,
          incantation: incantation,
          version: version
        });
      }
      console.log("PublicDB.get  <- ", bp);
      return bp;
      task = this.task('initialize bp or whatever');
      task.push(function(done){
        return bp.once_initialized(done);
      });
      return task.end(function(err, res){
        return console.log("we have the bp (and supposedly the instance)", res);
      });
    },
    patch: function(obj){
      return console.error("TODO: object patching");
    },
    initialize: function(){
      var task, this$ = this;
      console.log("initializing " + opts.name);
      this.blueprints = {};
      task = this.task("initialize PublicDB(" + opts.name + ")");
      task.push(function(done){
        this$.storage = new LocalDB({
          name: name
        });
        return this$.storage.once_initialized(function(){
          console.log("storage ready", arguments);
          return done();
        });
      });
      return task.end(function(err, res){
        if (err) {
          this$.emit('error', err);
          return this$.transitionSoon('error');
        } else {
          return this$.transitionSoon('ready');
        }
      });
    },
    states: {
      uninitialized: {
        onenter: function(){
          return this.debug("entered uninitialized... do nothing, for now");
        }
      },
      loading: {
        onenter: function(){
          var walker, this$ = this;
          walker = Walk(db_path, {
            max_depth: 1
          });
          walker.on('file', function(path, st){
            var file, idx, c;
            file = Path.basename(path);
            if (~(idx = file.indexOf(".blueprint.json")) && (c = file.substr(0, idx))) {
              if (c === 'undefined') {
                throw new Error("STOP!! you've got some heavy shit going on somewhere...");
              }
            }
          });
          return walker.on('end', function(err){
            if (err) {
              this$.emit('error', err);
              return this$.transition('error');
            } else {
              return this$.transition('ready');
            }
          });
        }
      },
      ready: {
        onenter: function(){
          return this.emit('ready');
        },
        fetch: function(fqvn, cb){
          var encantador, incantation, req;
          console.log("hello! we want to get", fqvn);
          if (typeof fqvn === 'string') {
            fqvn = parse_fqvn(fqvn);
          } else if (typeof fqvn !== 'object') {
            throw new Error("dude, you're fetching alll wrong...");
          }
          if (!(encantador = fqvn.encantador)) {
            throw new Error("you neeed to define the encantador");
          }
          if (!(incantation = fqvn.incantation)) {
            throw new Error("you need to define the incantation");
          }
          req = Http.get("/db/_bp/" + encantador + "/" + incantation, function(err, res){
            return cb(err, res);
          });
          return req.end();
        },
        dump: function(){
          var this$ = this;
          console.log("TODO: use the mongo functions to list out the collections", Mongoose.blueprints);
          debugger;
          return _.each(Mongoose.blueprints, function(blueprint, k){
            var collection_path;
            collection_path = Path.join(db_path, blueprint.collection.name);
            return ToolShed.mkdir(collection_path, function(err, dir){
              var task, stream;
              if (err) {
                return this$.emit('dump_failed', err);
              } else {
                task = this$.task("dumping collection " + blueprint.collection.name);
                stream = blueprint.find().lean().stream();
                stream.on('data', function(doc){
                  return task.push(function(done){
                    return ToolShed.writeFile(Path.join(collection_path, doc._id + '.json'), ToolShed.stringify(doc, void 8, "\t"), done);
                  });
                });
                stream.on('error', function(err){
                  return this$.emit('dump_failed', err);
                });
                return stream.on('close', function(){
                  return this$.emit('dump_complete');
                });
              }
            });
          });
        }
      }
    }
  });
  if (typeof db_ready === 'function') {
    debugger;
    this.until('ready', db_ready);
  }
  return self;
};
PublicDB.dbs = {};
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}