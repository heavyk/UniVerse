// Generated by LiveScript 1.2.0
var Path, Fs, Url, Http, ref$, Fsm, ToolShed, Debug, DaFunk, _, debug, levelJs, LocalDB, PublicDB, out$ = typeof exports != 'undefined' && exports || this;
Path = require('path');
Fs = require('fs');
Url = require('url');
Http = require('http');
ref$ = require('MachineShop'), Fsm = ref$.Fsm, ToolShed = ref$.ToolShed, Debug = ref$.Debug, DaFunk = ref$.DaFunk, _ = ref$._;
debug = Debug('PublicDB');
levelJs = require('level-js');
out$.LocalDB = LocalDB = (function(superclass){
  var i$, ref$, len$, k, prototype = extend$((import$(LocalDB, superclass).displayName = 'LocalDB', LocalDB), superclass).prototype, constructor = LocalDB;
  function LocalDB(options){
    var name;
    if (!(name = options.name)) {
      throw new Error("you must provide a 'name' for your LocalDB");
    }
    this.storage = levelJs(name);
    LocalDB.superclass.call(this, "LocalDB");
  }
  prototype.states = {
    uninitialized: {
      onenter: function(){
        var this$ = this;
        return this.storage.open(function(err){
          if (err) {
            return this$.transition('error');
          } else {
            return this$.transition('ready');
          }
        });
      }
    },
    ready: {
      onenter: function(){
        return this.emit('ready');
      }
    },
    error: {
      onenter: function(){
        return this.emit('error');
      }
    }
  };
  for (i$ = 0, len$ = (ref$ = ['get', 'set', 'remove', 'list', 'clear']).length; i$ < len$; ++i$) {
    k = ref$[i$];
    constructor.prototype[k] = fn$(k);
  }
  constructor.prototype.query = function(query){
    return this.debug.todo("query the LocalDB/PubliCDB");
  };
  return LocalDB;
  function fn$(k){
    return function(key, options, cb){
      var dfd;
      if (this.state === 'error') {
        if (typeof cb === 'function') {
          return cb({
            code: 'ERRNOTAVAILABLE'
          });
        }
      } else {
        dfd = this.storage[k].call(this.storage, key, options);
        if (typeof cb === 'function') {
          dfd.then(cb);
        }
        return dfd;
      }
    };
  }
}(Fsm));
out$.PublicDB = PublicDB = function(opts, db_ready){
  var debug, name, db, self, db_path;
  debug = Debug("PublicDB");
  if (typeof opts === 'string') {
    opts = {
      name: opts
    };
  } else if (typeof opts !== 'object') {
    opts = {};
  }
  if (!(name = opts.name)) {
    this.debug.error("you need a name for your database!");
  }
  if (db = PublicDB.dbs[opts.name]) {
    return db;
  }
  if (!opts.host) {
    opts.host = '127.0.0.1';
  }
  if (!opts.port) {
    opts.port = 8529;
  }
  self = PublicDB.dbs[opts.name] = new Fsm("PublicDB(" + opts.name + ")", {
    name: opts.name,
    opts: opts,
    path: db_path = Path.join('db', opts.name),
    get: function(encantador, incantation, version, opts){
      var i, long_incantation, bp, task;
      this.debug("PublicDB.get %j", arguments);
      if (typeof version === 'object') {
        opts = version;
        version = opts.version;
      }
      if (!version) {
        version = 'latest';
      }
      throw new Error(" don't use this for now ... use PoetryBook.get");
      if (~(i = incantation.indexOf('@'))) {
        version = incantation.substr(i + 1);
        incantation = incantation.substr(0, i);
      }
      long_incantation = encantador + ':' + incantation + '@' + version;
      if (typeof (bp = Blueprint._[long_incantation]) === 'undefined') {
        this.debug("new Blueprint");
        bp = new Blueprint(refs, {
          encantador: encantador,
          incantation: incantation,
          version: version
        });
      }
      this.debug("PublicDB.get  <- %s", long_incantation);
      return bp;
      task = this.task('initialize bp or whatever');
      task.push(function(done){
        return bp.once_initialized(done);
      });
      return task.end(function(err, res){
        return this.debug("we have the bp (and supposedly the instance) now, YAY!");
      });
    },
    patch: function(obj){
      return this.debug.todo("object patching");
    },
    initialize: function(){
      var task, this$ = this;
      this.debug("initializing " + opts.name);
      this.blueprints = {};
      task = this.task("initialize PublicDB(" + opts.name + ")");
      task.push(function(done){
        this$.storage = new LocalDB({
          name: name
        });
        return this$.storage.once_initialized(function(){
          this$.debug("storage ready");
          return done();
        });
      });
      return task.end(function(err, res){
        if (err) {
          this$.emit('error', err);
          return this$.transitionSoon('error');
        } else {
          return this$.transitionSoon('ready');
        }
      });
    },
    states: {
      uninitialized: {
        onenter: function(){
          return this.debug("entered uninitialized... do nothing, for now");
        }
      },
      loading: {
        onenter: function(){
          var walker, this$ = this;
          walker = Walk(db_path, {
            max_depth: 1
          });
          walker.on('file', function(path, st){
            var file, idx, c;
            file = Path.basename(path);
            if (~(idx = file.indexOf(".blueprint.json")) && (c = file.substr(0, idx))) {
              if (c === 'undefined') {
                throw new Error("STOP!! you've got some heavy shit going on somewhere...");
              }
            }
          });
          return walker.on('end', function(err){
            if (err) {
              this$.emit('error', err);
              return this$.transition('error');
            } else {
              return this$.transition('ready');
            }
          });
        }
      },
      ready: {
        onenter: function(){
          return this.emit('ready');
        },
        fetch: function(fqvn, cb){
          var encantador, incantation, req;
          this.debug("hello! we want to get: %s", fqvn);
          if (typeof fqvn === 'string') {
            fqvn = parse_fqvn(fqvn);
          } else if (typeof fqvn !== 'object') {
            throw new Error("dude, you're fetching alll wrong...");
          }
          if (!(encantador = fqvn.encantador)) {
            throw new Error("you neeed to define the encantador");
          }
          if (!(incantation = fqvn.incantation)) {
            throw new Error("you need to define the incantation");
          }
          req = Http.get("/db/_bp/" + encantador + "/" + incantation, function(err, res){
            return cb(err, res);
          });
          return req.end();
        },
        dump: function(){
          var this$ = this;
          throw new Error("redo this with DaFunk.stringify");
          return _.each(Mongoose.blueprints, function(blueprint, k){
            var collection_path;
            collection_path = Path.join(db_path, blueprint.collection.name);
            return ToolShed.mkdir(collection_path, function(err, dir){
              var task, stream;
              if (err) {
                return this$.emit('dump_failed', err);
              } else {
                task = this$.task("dumping collection " + blueprint.collection.name);
                stream = blueprint.find().lean().stream();
                stream.on('data', function(doc){
                  return task.push(function(done){
                    return ToolShed.writeFile(Path.join(collection_path, doc._id + '.json'), ToolShed.stringify(doc, void 8, "\t"), done);
                  });
                });
                stream.on('error', function(err){
                  return this$.emit('dump_failed', err);
                });
                return stream.on('close', function(){
                  return this$.emit('dump_complete');
                });
              }
            });
          });
        }
      }
    }
  });
  if (typeof db_ready === 'function') {
    debugger;
    this.until('ready', db_ready);
  }
  return self;
};
PublicDB.dbs = {};
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}