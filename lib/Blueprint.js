// Generated by LiveScript 1.2.0
var assert, Http, pathToRegexp, ref$, Fsm, ToolShed, DaFunk, _, Machina, StoryBook, ExperienceDB, Perspective, Quest, Tone, Timing, Meaning, Magnetism, embody_bp, get_bp, Blueprint, out$ = typeof exports != 'undefined' && exports || this;
assert = require('assert');
Http = require('http');
pathToRegexp = require('path-to-regexp');
ref$ = require('MachineShop'), Fsm = ref$.Fsm, ToolShed = ref$.ToolShed, DaFunk = ref$.DaFunk, _ = ref$._, Machina = ref$.Machina;
StoryBook = require('./StoryBook').StoryBook;
ref$ = require('./ExperienceDB'), ExperienceDB = ref$.ExperienceDB, Perspective = ref$.Perspective, Quest = ref$.Quest;
window.Machina = Machina;
Tone = {
  'also|initialize': function(){
    var k, ref$, p, this$ = this;
    for (k in ref$ = this._bp._blueprint.layout) {
      p = ref$[k];
      if (!p.hidden && typeof this.parts[k] === 'undefined') {
        this.parts[k] = fn$(p.render || p.type.toString().toLowerCase());
      }
    }
    if (this._bp.incantation === 'Login') {
      window.tone_ = this;
    }
    this._el.addEventListener("submit", function(e){
      e.preventDefault();
      this$.emit('submit', e);
      return false;
    });
    if (this._is_dirty) {
      return this.exec('verify');
    }
    function fn$(type){
      return function(E){
        return E('div', {
          c: "form-group " + type
        });
      };
    }
  },
  eventListeners: {
    verified: function(){
      debugger;
      return this.debug.todo("TODO: form verification");
    }
  },
  cmds: {
    verify: function(){
      if (this._is_verified) {
        return true;
      }
      this.debug.error("verify this for reals...");
      return this._is_verified = true;
    },
    field_entry: function(part, sv){
      var voice, _part, E, type, changed_val, el, icons, iin, this$ = this;
      voice = this;
      if (!(_part = this._parts[part])) {
        throw new Error("trying to render a part('" + part + "') but it isn't defined...");
      }
      E = cE;
      if (!sv.type) {
        debugger;
      }
      type = sv.type.toString().toLowerCase();
      changed_val = function(e){
        var val;
        return voice.set(part, typeof sv.onchange === 'function' && typeof (val = sv.onchange.call(voice, e.target.value)) !== 'undefined'
          ? val
          : e.target.value);
      };
      el = (function(){
        switch (sv.render) {
        case 'glyphicon':
          icons = ['glass', 'music', 'search', 'envelope', 'heart', 'star', 'star-empty', 'user', 'film', 'th-large', 'th', 'th-list', 'ok', 'remove', 'zoom-in', 'zoom-out', 'off', 'signal', 'cog', 'trash', 'home', 'file', 'time', 'road', 'download-alt', 'download', 'upload', 'inbox', 'play-circle', 'repeat', 'refresh', 'list-alt', 'lock', 'flag', 'headphones', 'volume-off', 'volume-down', 'volume-up', 'qrcode', 'barcode', 'tag', 'tags', 'poetry', 'bookmark', 'print', 'camera', 'font', 'bold', 'italic', 'text-height', 'text-width', 'align-left', 'align-center', 'align-right', 'align-justify', 'list', 'indent-left', 'indent-right', 'facetime-video', 'picture', 'pencil', 'map-marker', 'adjust', 'tint', 'edit', 'share', 'check', 'move', 'step-backward', 'fast-backward', 'backward', 'play', 'pause', 'stop', 'forward', 'fast-forward', 'step-forward', 'eject', 'chevron-left', 'chevron-right', 'plus-sign', 'minus-sign', 'remove-sign', 'ok-sign', 'question-sign', 'info-sign', 'screenshot', 'remove-circle', 'ok-circle', 'ban-circle', 'arrow-left', 'arrow-right', 'arrow-up', 'arrow-down', 'share-alt', 'resize-full', 'resize-small', 'plus', 'minus', 'asterisk', 'exclamation-sign', 'gift', 'leaf', 'fire', 'eye-open', 'eye-close', 'warning-sign', 'plane', 'calendar', 'random', 'comment', 'magnet', 'chevron-up', 'chevron-down', 'retweet', 'shopping-cart', 'folder-close', 'folder-open', 'resize-vertical', 'resize-horizontal', 'hdd', 'bullhorn', 'bell', 'certificate', 'thumbs-up', 'thumbs-down', 'hand-right', 'hand-left', 'hand-up', 'hand-down', 'circle-arrow-right', 'circle-arrow-left', 'circle-arrow-up', 'circle-arrow-down', 'globe', 'wrench', 'tasks', 'filter', 'briefcase', 'fullscreen', 'dashboard', 'paperclip', 'heart-empty', 'link', 'phone', 'pushpin', 'euro', 'usd', 'gbp', 'sort', 'sort-by-alphabet', 'sort-by-alphabet-alt', 'sort-by-order', 'sort-by-order-alt', 'sort-by-attributes', 'sort-by-attributes-alt', 'unchecked', 'expand', 'collapse', 'collapse-top'];
          return E('div', {
            c: "form-group " + (sv.render || type)
          }, E('label', {
            c: 'control-label col-lg-3 pull-left',
            'for': 'input_' + part
          }, sv.label || part), E('div', {
            c: 'col-lg-3 col-3'
          }, iin = E('input', {
            c: 'form-control',
            type: 'text',
            value: voice.get(part) || sv['default'] || '',
            id: 'input_' + part,
            placeholder: sv.onempty || '',
            onchange: changed_val
          })), function(){
            var b, pop;
            b = E('button', {
              c: 'btn btn-default'
            }, E('span', {
              c: 'glyphicon glyphicon-cog'
            }));
            return pop = window.$(b).popover({
              toggle: 'popover',
              content: function(){
                return _.map(icons, function(icon){
                  return E('button', {
                    c: "btn btn-mini " + (icon === iin.value ? 'btn-danger' : 'btn-primary'),
                    onclick: function(){
                      this.set(part, iin.value = icon);
                      return pop.popover('toggle');
                    }
                  }, E('span', {
                    c: "glyphicon glyphicon-" + icon
                  }));
                });
              },
              title: "choose your icon"
            });
          }, sv.onrender, sv.oninfo ? E('span', {
            c: 'help-block'
          }, sv.oninfo) : void 8);
        case 'colorpicker':
          return E('div', {
            c: "form-group " + (sv.render || type)
          }, E('label', {
            c: 'control-label col-lg-3 pull-left',
            'for': 'input_' + part
          }, sv.label || part), E('div', {
            c: 'col-lg-3 col-3'
          }, iin = E('input', {
            c: 'form-control',
            type: 'text',
            value: voice.get(part) || sv['default'] || '',
            id: 'input_' + part,
            placeholder: sv.onempty || '',
            onchange: function(e){
              return changed_val;
            }
          })), function(){
            var b, cp, pop;
            b = E('button', {
              c: 'btn btn-default pull-left'
            }, E('span', {
              c: 'glyphicon glyphicon-cog'
            }));
            cp = new window.ColorPicker;
            cp.on('change', function(e){
              var p;
              p = function(v){
                v = v.toString(16);
                if (v.length < 2) {
                  return '0' + v;
                } else {
                  return v;
                }
              };
              return this$.set(part, iin.value = p(e.r) + "" + p(e.g) + p(e.b));
            });
            return pop = window.$(b).popover({
              toggle: 'popover',
              content: function(){
                return cp.el;
              },
              title: "choose your color"
            });
          }, sv.onrender, sv.oninfo ? E('span', {
            c: 'help-block'
          }, sv.oninfo) : void 8);
        default:
          switch (type) {
          case 'string':
            return E('div', {
              c: "form-group " + (sv.render || type)
            }, E('label', {
              c: 'control-label col-lg-3',
              'for': 'input_' + part
            }, sv.label || part), sv.render === 'textarea'
              ? E('textarea', {
                c: 'form-control',
                id: 'input_' + part,
                placeholder: sv.onempty || '',
                onchange: changed_val,
                onkeyup: changed_val
              }, voice.get(part) || sv['default'] || '', sv.onrender)
              : E('input', {
                c: 'form-control',
                type: sv.render === 'password' ? 'password' : 'text',
                value: voice.get(part) || sv['default'] || '',
                id: 'input_' + part,
                placeholder: sv.onempty || '',
                onchange: function(){
                  changed_val.apply(this, arguments);
                  return voice.save();
                },
                onkeyup: changed_val
              }, sv.onrender), sv.oninfo ? E('span', {
              c: 'help-block'
            }, sv.oninfo) : void 8);
          case 'number':
            return E('div', {
              c: "form-group " + (sv.render || type)
            }, E('label', {
              c: 'control-label col-lg-3',
              'for': 'input_' + part
            }, sv.label || part), E('div', {
              c: 'col-lg-8'
            }, function(){
              var i, e;
              if (Array.isArray(sv['enum'])) {
                return E('div', {
                  c: 'btn-group',
                  data: {
                    toggle: 'buttons'
                  }
                }, (function(){
                  var i$, ref$, len$, results$ = [];
                  for (i$ = 0, len$ = (ref$ = sv['enum']).length; i$ < len$; ++i$) {
                    i = i$;
                    e = ref$[i$];
                    results$.push(E('label', {
                      c: 'btn btn-primary'
                    }, E('input', {
                      type: 'radio',
                      name: part,
                      id: part + '' + i
                    }), e));
                  }
                  return results$;
                }()));
              } else {
                return E('input', {
                  c: 'form-control',
                  type: sv.render === 'spinner' ? 'number' : 'range',
                  value: voice.get(part) || sv['default'].toString() || 0,
                  min: sv.min,
                  max: sv.max,
                  step: sv.step,
                  id: 'input_' + part,
                  placeholder: sv.onempty || '',
                  onchange: changed_val
                }, sv.onrender);
              }
            }), sv.oninfo ? E('span', {
              c: 'help-block'
            }, sv.oninfo) : void 8);
          case 'date':
            return E('div', {
              c: "form-group " + (sv.render || type)
            }, E('label', {
              c: 'control-label col-lg-3',
              'for': 'input_' + part
            }, sv.label || part), E('div', {
              c: 'col-lg-8'
            }, E('input', {
              c: 'form-control',
              type: 'text',
              id: 'input_' + part,
              placeholder: sv.onempty || '',
              onchange: function(e){
                return this$.set(part, new Date(e.target.value));
              }
            }, sv.onrender), sv.oninfo ? E('span', {
              c: 'help-block'
            }, sv.oninfo) : void 8));
          case 'boolean':
            return E('div', {
              c: "form-group " + (sv.render || type)
            }, E('label', {
              c: 'checkbox'
            }, E('input', {
              type: 'checkbox',
              checked: voice.get(part) || sv['default'] || false
            }), sv.label, sv.onrender), sv.oninfo ? E('span', {
              c: 'help-block',
              contentEditable: true
            }, sv.oninfo) : void 8);
          default:
            return E('div', {
              c: 'alert alert-error'
            }, "unknown schema type: " + sv.type);
          }
        }
      }());
      E.rC(_part, el);
      return el;
    }
  },
  states: {
    uninitialized: {
      onenter: function(){
        var schema, this$ = this;
        schema = [];
        _.each(this._renderers, function(field){
          var obj, o, k, v;
          obj = this$._bp._blueprint.layout[field];
          if (!obj.hidden) {
            o = {};
            for (k in obj) {
              v = obj[k];
              o[k] = v;
            }
            o.field = field;
            return schema.push(o);
          }
        });
        this._schema = schema;
        if (this.goto) {
          return this.transition(this.goto);
        }
      }
    },
    'new': {
      onenter: function(){
        if (!this.states['new'].renderers) {
          return this.states['new'].renderers = _.keys(this._bp._blueprint.layout);
        }
      }
    }
  }
};
Timing = {
  'also|initialize': function(){
    this.debug("welcome to an extension of Time");
    if (this.quests) {
      return DaFunk.extend(this.quests, this._bp._blueprint.quests);
    } else {
      return this.quests = this._bp._blueprint.quests;
    }
  },
  cmds: {
    more_quest: function(){
      if (!this.quest) {
        this.debug.error("not questing anything!");
        return;
      }
      if (!this.quest._id) {
        this.debug.error("nothing more to quest!");
        return;
      }
      return this.quest.exec('more_quest');
    },
    quest: function(key, opts){
      var q, verse;
      if (this.quest) {
        this.debug.error("this is probably an error because the event listeners need to be removed from the old quest and we neeed to garbage collect ot correctly");
      }
      this.quest = q = new Quest(this._bp, key, opts);
      verse = this;
      q.on('*', function(){
        verse.emit.apply(this, arguments);
      });
      return this.transition(key);
    }
  }
};
Meaning = (function(superclass){
  var window, cE, aC, $, prototype = extend$((import$(Meaning, superclass).displayName = 'Meaning', Meaning), superclass).prototype, constructor = Meaning;
  function Meaning(book, _bp, key, opts){
    var self, client_key, id, el_opts;
    this.book = book;
    this._bp = _bp;
    this.push_path = bind$(this, 'push_path', prototype);
    this.replace_path = bind$(this, 'replace_path', prototype);
    self = this;
    self._is_dirty = false;
    self._dirty_vals = {};
    self._is_new = true;
    client_key = Math.random().toString(32).substr(2);
    self.refs = book.refs;
    if (typeof key === 'object') {
      self._xp = key;
      self._xp._k = client_key;
      self._is_dirty = true;
      key = key._key;
    }
    if (typeof key === 'string') {
      self.id = id = _bp.type === 'Mutable'
        ? 'quest:' + key
        : _bp.incantation + '/' + key;
    } else {
      self.id = _bp.incantation + '/' + client_key;
    }
    window = book.refs.window;
    cE = window.cE;
    aC = window.aC;
    this._cE = function(){
      return cE.apply(self, arguments);
    };
    this._cE.$ = $ = window.$;
    this._cE.rC = window.rC;
    this.poetry = book.poetry;
    this.memory = book.memory[_bp.incantation];
    this._parts = {};
    if (typeof opts === 'object') {
      if (typeof opts.el !== 'undefined') {
        self._el = opts.el;
        delete opts.el;
      }
      DaFunk.extend(self, opts);
    }
    switch (_bp.type) {
    case 'Cardinal':
      if (this._xp) {
        this._xp_tpl = import$({}, this._xp);
        this._xp._k = client_key;
      }
      if (self._el === void 8) {
        self._el = 'form';
      }
      break;
    case 'Mutable':
      if (key) {
        this.initialState = key;
      }
    }
    if (!this._xp) {
      this._xp = {
        _k: client_key
      };
    }
    if (typeof self._el === 'undefined') {
      self._el = 'div';
    }
    if (typeof self._el === 'string') {
      el_opts = _bp.encantador
        ? {
          c: _bp.encantador + ' ' + _bp.incantation + ' container-fluid'
        }
        : {};
      self._el = cE(self._el, el_opts);
    } else if (typeof self._el === 'function') {
      self._el = self._el.call(this, cE);
    } else if (typeof self._el !== 'object') {
      throw new Error("I dunno what to do! " + typeof self._el);
    }
    self._el.dataset.blueprint = _bp.fqvn;
    self._el._machina = self;
    if (_bp.type === 'Fixed' && id) {
      this._loading = key;
    }
    if (!this.parts) {
      this.parts = {};
    }
    Meaning.superclass.call(this, _bp.encantador + ":" + _bp.incantation + "(" + (key
      ? key
      : _bp.type === 'Fixed'
        ? 'new'
        : _bp.type) + ")");
    this._bp.emit('register', this);
    if (!this.id) {
      debugger;
    }
    switch (_bp.type) {
    case 'Mutable':
      if (key) {
        self.exec('quest', key, opts);
      }
      break;
    case 'Abstract':
      this.debug.error("type is changed to significance");
      if (key) {
        self.transition(key);
      }
      break;
    case 'Cardinal':
      this.debug.todo("we need cardinal types...");
      if (typeof key === 'string') {
        this.debug.todo("load up the exp using this id");
      }
      // fallthrough
    case 'Fixed':
      // fallthrough
    default:
      if (id && _bp._blueprint.presence !== 'Abstract') {
        self.exec('load', key);
      }
    }
  }
  prototype.render = function(){
    return "this is " + this.namespace;
  };
  prototype.router = function(path, is_back){
    var window_href, window_href_base, proto, url_poem, ref$, i, querystring, lala;
    window_href = window.location.href + '';
    window_href_base = window_href.substr(0, window_href.lastIndexOf('/'));
    proto = cur_proto;
    url_poem = cur_url_poem;
    if (~path.indexOf(window_href_base)) {
      path = path.substr(window_href_base.length);
    } else {
      if (~path.indexOf("://")) {
        proto = path.split('://');
        if (proto.length > 1) {
          ref$ = proto, proto = ref$[0], path = ref$[1];
        } else {
          proto = 'http';
          path = proto[0];
        }
      }
      if ((i = path.indexOf('/')) > 0) {
        url_poem = path.substr(0, i);
        path = path.substr(i);
      } else if (i === 0) {
        url_poem = cur_url_poem;
        path = path;
      } else {
        url_poem = path;
        path = '/';
      }
    }
    querystring = '';
    if (i = ~path.indexOf('?')) {
      querystring = path.slice(i + 1);
      path = path.slice(0, i);
    }
    this.debug("proto:" + proto + " url_poem:" + url_poem + " path:" + path);
    switch (path) {
    case '/disconnected':
      this.debug.todo("TODO: show disconnected thing...");
      refs.poem.emit('disconnected');
      aC(null, lala = cE('div', {
        c: 'modal-backdrop fade in'
      }));
      return window.fsm.on('ready', function(){
        return $(lala).remove();
      });
    }
  };
  prototype._render = function(){
    return this._el;
  };
  prototype.action_up = function(path, evt){
    var el, machina;
    el = this._el.parentNode;
    do {
      if (machina = el._machina) {
        process.nextTick(fn$);
        return machina;
      }
    } while (el = el.parentNode);
    return null;
    function fn$(){
      if (machina.states[machina.state][path]) {
        return machina.exec(path, evt);
      } else {
        return machina.transition(path);
      }
    }
  };
  prototype.exp = function(no_default){
    var d;
    if (no_default) {
      d = _.cloneDeep(this._xp);
      _.each(this._bp.layout, function(v, k){
        if (v.required) {
          d[k] = this.get(k);
        }
      }, this);
    } else {
      d = {};
      _.each(this._bp.layout, function(v, k){
        if (typeof (v = this.get(k, no_default)) !== 'undefined') {
          d[k] = v;
        }
      }, this);
    }
    return d;
  };
  prototype.get = function(path, no_default){
    var v, s;
    if (this.__loading) {
      return "loadi___ng...";
    }
    if (typeof (v = ~path.indexOf('.')
      ? get_path(this._xp, path)
      : this._xp[path]) === 'undefined' && !no_default && typeof (s = this._bp.layout[path]) !== 'undefined') {
      if (typeof (v = s['default']) === 'function') {
        v = v.call(this, s);
      }
    }
    return v;
  };
  prototype.set = function(path, val){
    var prev_val;
    this.debug("set: %s %s %s", path, val, DaFunk.stringify(this._xp));
    assert(this._bp._blueprint.type !== 'Abstract');
    if (path === '_rev' || path === '_key' || path === '_id') {
      this.debug.error("'_rev', '_key' and '_id' are immutable properties. you have a bug somewhere...");
      return this._xp[path];
    }
    prev_val = ~path.indexOf('.')
      ? get_path(this._xp, path, val)
      : this._xp[path];
    if (!_.isEqual(val, prev_val)) {
      this._is_dirty = true;
      if (~path.indexOf('.')) {
        set_path(this._xp, path, val);
      } else {
        this._xp[path] = val;
      }
      this._dirty_vals[path] = val;
      this.emit('set', path, val);
      return val;
    }
  };
  prototype.forget = function(cb){
    this.debug("forgetting %s", this.key);
    if (this._is_new) {
      this.exec('make_new');
      if (typeof cb === 'function') {
        return cb.call(this, null, this);
      }
    } else {
      return this.memory.forget(this.key, cb);
    }
  };
  prototype.save = function(cb){
    var d, this$ = this;
    if (this._bp._blueprint.presence === 'Abstract') {
      return;
    }
    if (this._is_new) {
      d = this.exp(true);
      if (d._rev) {
        this.debug.error("TODO: you have a bug somewhere... you shouldn't have a _rev ever!!");
      }
      return this.memory.create(this._xp, function(err, xp){
        if (err) {
          this$.emit('error', err);
        } else {
          this$.emit('created', xp);
        }
        if (typeof cb === 'function') {
          return cb.apply(this$, arguments);
        }
      });
    } else if (this._is_dirty) {
      this.debug("saving dirty experience %s <= %s", DaFunk.stringify(this._xp), DaFunk.stringify(this._dirty_vals));
      return this.memory.patch(this.key, this._dirty_vals, function(err, xp){
        if (err) {
          this$.emit('error', err);
        } else {
          this$.emit('patched', xp);
        }
        if (typeof cb === 'function') {
          return cb.apply(this$, arguments);
        }
      });
    } else {
      return cb.call(this, void 8, this._xp);
    }
  };
  prototype.eventListeners = {
    transition: function(evt){
      var set_path, self, cE, aC, path, from_state, cur_state, part_order, parts, pi, i$, len$, i, k, part, p, wrong_one, do_render;
      set_path = 1;
      self = this;
      cE = self._cE;
      aC = self.refs.window.aC;
      path = evt.toState;
      from_state = evt.fromState;
      cur_state = this.states[path];
      part_order = cur_state.order
        ? cur_state.order
        : this.order;
      parts = cur_state.parts
        ? cur_state.parts
        : this.parts;
      if (typeof part_order === 'string') {
        part_order = [part_order];
      } else if (!part_order) {
        part_order = ['render'];
        if (!parts) {
          this._parts.render = this._el;
        }
      }
      if (!Array.isArray(part_order)) {
        throw new Error("blueprint '" + this._bp.fqvn + "' does not specify 'order' for its parts: " + Object.keys(this.parts) + " - or at least it's not an array...");
      }
      if (typeof parts !== 'object') {
        throw new Error("you have not defined this blueprint's parts or the state's parts...");
      }
      if (part_order) {
        pi = 0;
        for (i$ = 0, len$ = part_order.length; i$ < len$; ++i$) {
          i = i$;
          k = part_order[i$];
          part = this._parts[k];
          if (!part && (typeof (p = parts[k]) === 'function' || typeof (p = this.parts[k]) === 'function')) {
            this._parts[k] = part = p.call(this, cE);
          }
          if (part) {
            if ((wrong_one = this._el.childNodes[pi]) !== part) {
              if (wrong_one) {
                this._el.removeChild(wrong_one);
              }
              if (part.parentNode === this._el) {
                this._el.removeChild(part);
              }
              aC(this._el, part, pi);
            }
            pi++;
          }
        }
        part = this._el.childNodes[part_order.length];
        while (part && (part = part.nextSibling)) {
          this._el.removeChild(part);
        }
      }
      do_render = function(renderer){
        var rr, ret, r, data, el;
        if (typeof self.state !== 'undefined') {
          if (this.cmds.field_entry && (rr = this._bp.layout[renderer])) {
            return ret = this.exec('field_entry', renderer, rr);
          } else if (typeof (r = self.states[typeof from_state !== 'undefined' && self._loading ? 'loading' : path][renderer]) === 'function') {
            data = evt.args[0];
            if ((typeof self._parts === 'undefined' && (el = self._el)) || (typeof self._parts === 'object' && (el = self._parts[renderer]))) {
              rr = r.call(self, cE, data);
              rC.call(this, el, rr);
            } else {
              set_path--;
            }
            if (path[0] === '/') {
              if (typeof from_state === 'string' && from_state[0] !== '/') {
                data = {
                  path: path,
                  mun: UniVerse.mun,
                  poem: UniVerse.poem
                };
                return self.replace_path(data, "some title");
              } else if (set_path && data) {
                UniVerse.poem = data.poem;
                return self.push_path(data, data.title + "");
              }
            }
          }
        }
      };
      if (part_order) {
        for (i$ = 0, len$ = part_order.length; i$ < len$; ++i$) {
          p = part_order[i$];
          do_render.call(this, p);
        }
      } else {
        do_render.call(this, 'render');
      }
    },
    added: function(el){},
    removed: function(el){
      throw new Error("wtf dude. not yet implemented");
    },
    destroy: function(){
      var el;
      this.debug("destroying...");
      el = this._el;
      if (el) {
        el._machina = null;
        if (el.parentNode) {
          return $(el).remove();
        }
      }
    },
    invalidstate: function(e){
      var path, poem;
      path = e.attemptedState;
      poem = this;
      if (path[0] === '/' && poem._regex_routes) {
        _.each(poem._regex_routes, function(regex, p){
          var m, params, url;
          if (~path.indexOf(regex.at_least)) {
            m = path.match(regex);
            if (m) {
              m.shift();
              params = {};
              _.each(m, function(p, i){
                return params[regex.keys[i].name] = p;
              });
              url = e.args[0];
              url.params = params;
              poem.transition(p, url);
              return false;
            }
          }
        });
      }
      this.debug.error("oh shit we're invalid (" + e.state + " -> " + e.attemptedState + ") %s", this._bp.encantador);
      this.debug.todo("moved to invalid state... if in debug mode, try to load the bluprint so you get to make the state right there...");
      debugger;
    }
  };
  prototype['memory:found'] = function(xp){
    var key;
    this._loading = null;
    this.key = key = xp._key;
    this.id = xp._id;
    this._is_new = false;
    this._is_new = !xp._rev;
    if (this._is_dirty) {
      this._is_dirty = false;
      this._dirty_vals = {};
    }
    this.memory.on("changed:" + key, _.bind(this['memory:changed'], this));
    this.memory.on("deleted:" + key, _.bind(this['memory:deleted'], this));
    this._xp = xp;
    if (this.state) {
      if (this.state === this.initialState) {
        if (typeof this.goto === 'string') {
          this.transition(this.goto);
        } else {
          this.transition('ready');
        }
      } else {
        this.emit('transition', {
          fromState: this.state,
          toState: this.state,
          args: []
        });
      }
    } else {
      this.transition('uninitialized');
    }
    this.memory.off("!found:" + key, _.bind(this['memory:!found'], this));
    this.memory.off("found:" + key, _.bind(this['memory:found'], this));
  };
  prototype['memory:changed'] = function(xp){
    debugger;
    this.exec('changed', xp, old_xp, diff);
  };
  prototype['memory:deleted'] = function(){
    this.transition('deleted');
  };
  prototype['memory:!found'] = function(){
    this._loading = null;
    this.exec('make_new');
    debugger;
    this.transition('not_found');
  };
  prototype['memory:error'] = function(err){
    this._loading = null;
    this.transition(err.code ? err.code : 'error');
  };
  prototype.cmds = {
    make_new: function(erase_vals){
      if (erase_vals) {
        this._xp = DaFunk.extend({}, this._xp_tpl);
      } else {
        this._xp = DaFunk.extend({}, this._xp);
      }
      this._is_new = true;
      this._dirty_vals = {};
      return this._is_dirty = false;
    },
    load: function(key, cb){
      var incantation, xp, cb_state, this$ = this;
      if (typeof key === 'function') {
        cb = key;
        key = this.key;
      }
      incantation = this._bp.incantation;
      this.debug("load: %s", key);
      if (typeof key === 'number') {
        key = this._bp.incantation + '/' + key;
      }
      if (typeof key === 'string') {
        if (~key.indexOf('/')) {
          debugger;
        }
        this.memory.on("error:" + key, _.bind(this['memory:error'], this));
        if (xp = this.memory.get(key)) {
          this['memory:found'](xp);
          if (typeof cb === 'function') {
            debugger;
            cb_state = cb(void 8, xp);
          }
          return this.transition(typeof cb_state === 'string' && this.states[cb_state]
            ? cb_state
            : this.state !== this.initialState ? this.state : 'ready');
        } else {
          this.memory.on("found:" + key, function(){
            return this$['memory:found'].apply(this$, arguments);
          });
          this.memory.on("!found:" + key, function(){
            return this$['memory:!found'].apply(this$, arguments);
          });
          return this._loading = key;
        }
      } else {
        throw new Error("we don't know what kind of key this is: " + id + " ... unable to load");
        this.debug.todo("check to see if it has a key");
        return this.debug.todo("@exec");
      }
    }
  };
  prototype.states = {
    uninitialized: {
      onenter: function(){}
    },
    loading: {
      render: function(E){
        return E('div', {
          c: 'loading'
        }, "loading...");
      }
    },
    'new': {
      onenter: function(){},
      render: function(E){
        return "TODO: new " + this.namespace + "... add the voice";
      }
    },
    edit: {
      onenter: function(){},
      render: function(E){}
    },
    ready: {
      onenter: function(){},
      render: function(E){
        return E('h4', null, "Meaning::ready", "(this is a bug because it stould initialize in the uninitialized state)");
      }
    },
    invalidstate: {
      onenter: function(e){},
      render: function(E){
        return E('div', {
          c: 'todo',
          data: {
            todo: "new_page_editor"
          }
        }, "invalid state: TODO: make a new page editor");
      }
    }
  };
  prototype.path = '/';
  prototype.replace_path = function(data, title){
    this.debug("replacing path %s with title '%s'", data.path, title);
    this.debug.todo("if history is an array, make sure the ... wait, the latest, is the current one, right?");
    this.path = data.path;
    this.path.data = data;
    if (title) {
      return this.title = title;
    }
  };
  prototype.push_path = function(data, title){
    this.debug("pushing path %s with title '%s'", data.path, title);
    if (!this.history) {
      this.history = [];
    }
    this.history.push(this.title);
    return this.replace_path(data, title);
  };
  return Meaning;
}(Fsm));
Magnetism = {
  emit: function(){
    return (function(){
      debugger;
    }());
  }
};
embody_bp = function(bp){
  var embody_bps, embody_bp_, embodies, embodied_bp, bpz, eb, i$, ref$, len$, incantation;
  if (!bp) {
    throw new Error("can't extend empty bp " + bp);
  }
  embody_bps = [];
  embody_bp_ = [];
  embodies = bp.encantador === bp.incantation
    ? bp.embodies
    : [bp.incantation];
  if (typeof embodies === 'string') {
    embodies = [embodies];
  }
  if (_.isArray(embodies) && embodies.length) {
    while (embodied_bp = embodies.shift()) {
      bpz = get_bp(bp.encantador, embodied_bp);
      if (eb = bpz.embodies) {
        for (i$ = 0, len$ = (ref$ = typeof eb === 'string' ? [eb] : eb).length; i$ < len$; ++i$) {
          incantation = ref$[i$];
          if (!~embody_bp_.indexOf(incantation)) {
            embodies.unshift(incantation);
          }
        }
        embody_bps.push(bpz);
        embody_bp_.push(bpz.incantation);
      }
    }
    embody_bps.unshift(get_bp(bp.encantador, bp.encantador));
    embody_bp_.unshift(bp.encantador);
    embody_bps.unshift(bp);
    embody_bp_.unshift(bp.incantation);
    return Da_Funk.embody.apply(this, embody_bps);
  } else {
    return bp;
  }
};
get_bp = function(encantador, incantation, version){
  var ref$, idx, bp;
  if (typeof encantador === 'object') {
    ref$ = encantador, encantador = ref$.encantador, incantation = ref$.incantation, version = ref$.version;
  }
  if (~(idx = incantation.indexOf('@'))) {
    version = incantation.substr(idx + 1);
    incantation = incantation.substr(0, idx);
  }
  if (version && version !== 'latest') {
    bp = Blueprint_collection.byExample({
      encantador: encantador,
      incantation: incantation,
      version: version
    });
  } else {
    bp_query.bind('encantador', encantador);
    bp_query.bind('incantation', incantation);
    bp = bp_query.execute();
  }
  return bp.next();
};
Blueprint = (function(superclass){
  var prototype = extend$((import$(Blueprint, superclass).displayName = 'Blueprint', Blueprint), superclass).prototype, constructor = Blueprint;
  function Blueprint(refs, opts){
    this.refs = refs;
    if (typeof opts === 'object') {
      if (opts.encantador) {
        this.encantador = opts.encantador;
      }
      if (opts.incantation) {
        this.incantation = opts.incantation;
      }
      if (opts.version) {
        this.version = opts.version;
      }
    } else if (typeof opts === 'string') {
      throw new Error("TODO: fqvn parsing");
    } else {
      throw new Error("we don't know whot to do with your blueprint, sorry");
    }
    if (typeof refs !== 'object') {
      this.debug.error("you need to pass a 'refs' object to the StoryBook");
    } else if (!refs.book) {
      throw new Error("you have to reference a PoetryBook for a blueprint because we save the imbuement into the poetry book, obviously");
    }
    this._blueprint = opts;
    this._instances = [];
    if (!this.incantation) {
      this.debug.error("you need a incantation for your blueprint!");
      throw new Error("you need a incantation for your blueprint!");
    }
    if (!this.encantador) {
      this.debug.error("you need a encantador for your blueprint!");
      throw new Error("you need a encantador for your blueprint!");
    }
    if (!this.version || this.version === '*') {
      this.version = 'latest';
    }
    Blueprint.superclass.call(this, "Blueprint(" + (this.fqvn = this.encantador + ':' + this.incantation + '@' + this.version) + ")");
  }
  prototype.imbue = function(book, cb){
    var blueprint_inst, library, _bp, _deps, _blueprint, deps, i$, len$, d, bp, task, this$ = this;
    assert(book instanceof StoryBook);
    if (this.state === 'ready') {
      library = this.refs.library;
      _bp = this;
      _deps = this._deps;
      _blueprint = this._blueprint;
      if (typeof book.memory[this.incantation] === 'undefined') {
        book.memory[this.incantation] = new ExperienceDB(this.incantation);
      }
      if (typeof book.poetry[this.encantador] === 'undefined') {
        eval("(function(){\n	var " + this.encantador + " = blueprint_inst = (function(superclass){\n		var prototype = extend$((import$(" + this.encantador + ", superclass).displayName = '" + this.encantador + "', " + this.encantador + "), superclass).prototype, constructor = " + this.encantador + ";\n		function " + this.encantador + " (book, _bp, key, opts) {\n			if(!(this instanceof " + this.encantador + ")) return new " + this.encantador + "(key, opts);\n			//" + (this.type === 'Cardinal' ? 'DaFunk.extend(this, DefineTone);' : '') + "\n			//" + (this.type === 'Mutable' ? 'DaFunk.extend(this, DefineTiming);' : '') + "\n			//" + (this.type === 'Fixed' ? 'DaFunk.extend(this, DefineSymbolic);' : '') + "\n			" + this.encantador + ".superclass.call(this, book, _bp, key, opts);\n		}\n		DaFunk.extend(prototype, _blueprint.machina);\n		return " + this.encantador + ";\n	}(Meaning));\n	DaFunk.extend(" + this.encantador + ", Magnetism);\n	book.poetry['" + this.encantador + "'] = " + this.encantador + ";\n}())");
      }
      if (this.encantador !== this.incantation) {
        eval("(function(){\n	var " + this.incantation + " = blueprint_inst = (function(superclass){\n		var embodies = _deps.embodies, prototype = extend$((import$(" + this.encantador + ", superclass).displayName = '" + this.encantador + "', " + this.encantador + "), superclass).prototype, constructor = " + this.encantador + ";\n		function " + this.encantador + " (key, opts) {\n			if(!(this instanceof " + this.encantador + ")) return new " + this.encantador + "(key, opts);\n			" + (this.type === 'Cardinal' ? 'DaFunk.extend(this, Tone);\n' : '') + "\n			" + (this.type === 'Mutable' ? 'DaFunk.extend(this, Timing);\n' : '') + "\n			//" + (this.type === 'Fixed' ? 'DaFunk.extend(this, Symbolic);\n' : '') + "\n			" + this.encantador + ".superclass.call(this, book, _bp, key, opts);\n		}\n		DaFunk.extend(prototype, _blueprint.machina);\n		return " + this.encantador + ";\n	}(book.poetry['" + this.encantador + "']));\n	book.add_poetry('" + this.encantador + "', '" + this.incantation + "', '" + this.version + "', " + this.incantation + ");\n}())");
      }
      _bp.on('diff', function(diff){
        console.log("got diff!", diff.path);
        switch (diff.path[0]) {
        case 'machina':
          return ToolShed.set_obj_path(diff.path.slice(1), blueprint_inst.prototype, diff.rhs);
        default:
          return console.log("unknown blueprint update", diff);
        }
      });
      if ((deps = Object.keys(this._deps)) && deps.length) {
        for (i$ = 0, len$ = deps.length; i$ < len$; ++i$) {
          d = deps[i$];
          bp = this._deps[d];
          if (typeof bp === 'object' && (!book.poetry[this.encantador] || !book.poetry[this.encantador][this.incantation])) {
            if (!task) {
              task = this.task("get deps");
            }
            task.push(fn$);
          }
        }
      }
      if (typeof cb === 'function') {
        if (task) {
          task.end(function(err){
            return cb(err, blueprint_inst);
          });
        } else {
          cb(null, blueprint_inst, this);
        }
        return;
      }
    } else if (typeof cb === 'function') {
      this.once('state:new', function(){
        var err;
        err = new Error("blueprint cannot be located so we're assuming it's new for now");
        err.code = 'ENOOB';
        cb(err, null, this$);
      });
      this.once('state:error', function(){
        var err;
        err = new Error("blueprint has some sort of error");
        err.code = 'ENOENT';
        cb(err, null, this$);
      });
      this.once('state:ready', function(){
        var imbued;
        imbued = this$.imbue(book);
        cb(null, imbued, this$);
      });
    } else {
      this.debug.error("you can't imbue a blueprint that's not yet ready! - use a callback to wait for it: " + this.fqvn);
    }
    return blueprint_inst;
    function fn$(done){
      return bp.imbue(book, done);
    }
  };
  prototype.eventListeners = {
    diff: function(diff){
      var i$, ref$, len$, inst, results$ = [];
      this.debug("re-render after applying diff");
      console.log("re-render");
      for (i$ = 0, len$ = (ref$ = this._instances).length; i$ < len$; ++i$) {
        inst = ref$[i$];
        results$.push(inst.emit('transition', {
          fromState: inst.priorState,
          toState: inst.state,
          args: []
        }));
      }
      return results$;
    },
    register: function(inst){
      return this._instances.push(inst);
    }
  };
  prototype.states = {
    uninitialized: {
      onenter: function(){
        var process_bp, req, this$ = this;
        process_bp = function(){
          var bp, _deps, long_incantation, embodies, UniVerse, book, task;
          if (!(bp = this$._blueprint)) {
            debugger;
            return;
          }
          this$.type = bp.type
            ? bp.type
            : (function(){
              switch (bp.encantador) {
              case 'Poem':
              case 'Word':
                return 'Fixed';
              case 'Verse':
                return 'Mutable';
              case 'Voice':
                return 'Cardinal';
              }
            }());
          this$.layout = bp.layout || {};
          this$._deps = {};
          _deps = DaFunk.embody({}, bp.poetry);
          this$.debug("deps", _deps);
          long_incantation = this$.fqvn;
          embodies = bp.embodies;
          if (typeof embodies === 'string') {
            embodies = [embodies];
          }
          this$._deps.embodies = embodies;
          UniVerse = this$.refs.UniVerse;
          if (!(book = this$.refs.book)) {
            debugger;
          }
          task = this$.task("get deps for " + this$.fqvn);
          if (this$.encantador !== this$.incantation) {
            task.push("getting encantador: " + this$.encantador, function(done){
              var encantador, incantation, version, idx, this$ = this;
              encantador = incantation = this.encantador;
              version = 'latest';
              if (~(idx = incantation.indexOf('@'))) {
                version = incantation.substr(idx + 1);
                encantador = incantation = incantation.substr(0, idx);
              }
              return UniVerse.library.exec('fetch', {
                encantador: encantador,
                incantation: incantation,
                version: version
              }, this.refs.book, function(err, bp){
                this$.debug("fetched... %s:%s", encantador, incantation);
                this$._deps.encantador = bp;
                return done();
              });
            });
          }
          if (embodies) {
            _.each(embodies, function(incantation, ii){
              return task.push("getting embodied: " + incantation, function(done){
                var encantador, version, idx, this$ = this;
                if (!incantation) {
                  debugger;
                }
                encantador = this.encantador;
                version = 'latest';
                if (~(idx = incantation.indexOf('@'))) {
                  version = incantation.substr(idx + 1);
                  incantation = incantation.substr(0, idx);
                }
                return UniVerse.library.exec('fetch', {
                  encantador: encantador,
                  incantation: incantation,
                  version: version
                }, this.refs.book, function(err, bp){
                  this$._deps.embodies[ii] = bp;
                  return done();
                });
              });
            });
          }
          _.each(_deps, function(deps, encantador){
            return _.each(deps, function(version, incantation){
              this$.debug("getting element: " + encantador + ":" + incantation + "@" + version);
              return task.push("getting element: " + encantador + ":" + incantation + "@" + version, function(done){
                var this$ = this;
                return UniVerse.library.exec('fetch', {
                  encantador: encantador,
                  incantation: incantation,
                  version: version
                }, this.refs.book, function(err, bp){
                  this$.debug("got element: " + encantador + ":" + incantation + "@" + version);
                  this$._deps[bp.fqvn] = bp;
                  return done();
                });
              });
            });
          });
          return task.end(function(err, res){
            return this$.transitionSoon('ready');
          });
        };
        return req = Http.get({
          path: "/bp/" + this.encantador + "/" + this.incantation + (this.version && this.version !== 'latest' ? '?version=' + this.version : '')
        }, function(res){
          var data;
          data = '';
          res.on('error', function(err){
            return this.debug.error("we've got an error!!", err);
          });
          res.on('data', function(buf){
            return data += buf;
          });
          res.on('end', function(){
            if (res.statusCode === 200) {
              this$._blueprint = DaFunk.objectify(data, {
                require: this$.refs.book.refs.require
              }, {
                name: this$.namespace
              });
              if (this$.version === 'latest') {
                this$.version = this$._blueprint.version;
              }
              this$.fqvn = this$.encantador + ':' + this$.incantation + '@' + this$.version;
              this$.refs.library.blueprints[this$.fqvn] = this$;
              if (typeof this$.refs.book._[this$.encantador] !== 'object') {
                this$.refs.book._[this$.encantador] = {};
              }
              if (typeof this$.refs.book._[this$.encantador][this$.version] !== 'object') {
                this$.refs.book._[this$.encantador][this$.version] = {};
              }
              return process_bp();
            } else if (res.statusCode === 204) {
              return this$.transition('new');
            } else {
              return this$.transition('error');
            }
          });
        });
      }
    },
    ready: {
      verify: function(path, val){}
    },
    error: {
      onenter: function(){
        return this.debug.error("you have tried to load a blueprint which wasn't able to be fetched", this.incantation);
      }
    },
    'new': {
      onenter: function(){
        return this.debug.todo("nice you don't know this bp yet, so now is the time to make it - make bp creation interface");
      }
    }
  };
  return Blueprint;
}(Fsm));
out$.Meaning = Meaning;
out$.Blueprint = Blueprint;
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}