// Generated by LiveScript 1.2.0
var Http, assert, ref$, Fsm, ToolShed, _, UniVerse, Blueprint, StoryBook, Library, out$ = typeof exports != 'undefined' && exports || this;
Http = require('http');
assert = require('assert');
ref$ = require('MachineShop'), Fsm = ref$.Fsm, ToolShed = ref$.ToolShed, _ = ref$._;
UniVerse = require('./UniVerse').UniVerse;
Blueprint = require('./Blueprint').Blueprint;
StoryBook = require('./StoryBook').StoryBook;
out$.Library = Library = (function(superclass){
  var prototype = extend$((import$(Library, superclass).displayName = 'Library', Library), superclass).prototype, constructor = Library;
  function Library(refs, opts){
    this.refs = refs;
    if (typeof refs !== 'object') {
      throw new Error("you need some references for your library");
    } else if (typeof refs.archive !== 'object') {
      throw new Error("you need a reference to your PublicDB blueprints [storage]");
    }
    this.blueprints = {};
    this.__loading = {};
    this.memory = {};
    this.archive = refs.archive;
    Library.superclass.call(this, "Library");
  }
  prototype.states = {
    uninitialized: {
      onenter: function(){
        console.log("we're uninitialized...");
        return this.transition('ready');
      }
    },
    ready: {
      onenter: function(){},
      'get:exp': function(incantation, key, cb){
        var req, this$ = this;
        this.__loading = req = Http.get({
          path: "/db/" + incantation + "/" + key
        }, function(res){
          var data;
          this$.__loading = null;
          data = '';
          res.on('error', function(err){
            return console.error("we've got an error!!", err);
          });
          res.on('data', function(buf){
            return data += buf;
          });
          res.on('end', function(){
            var xp;
            console.log("done with the request:", res);
            this$._loading = null;
            if (res.statusCode === 200) {
              xp = ToolShed.objectify(data, {}, {
                name: this$.id
              });
              this$.debug("yay, we have the experience... store it");
              return this$.memory[incantation].set(xp);
            } else {
              this$.emit('error', {
                code: 'ENOENT'
              });
              return this$.transition(res.statusCode);
            }
          });
        });
        this._loading = id;
        if (typeof cb === 'function') {
          return cb(null, {
            yay: true
          });
        }
      },
      fetch: function(fqvn, book, cb){
        var incantation, i, encantador, version, long_incantation, bp, refs, timeout;
        if (typeof book === 'function') {
          cb = book;
        }
        this.debug("fetching blueprint..");
        this.debug.warn("TODO: save the blueprint into poetry and return the blueprint");
        if (typeof fqvn === 'string') {
          incantation = fqvn;
          if (~(i = incantation.indexOf(':'))) {
            encantador = incantation.substr(0, i);
            incantation = incantation.substr(i + 1);
            if (~(i = incantation.indexOf('@'))) {
              version = incantation.substr(i + 1);
              incantation = incantation.substr(0, i);
            }
          }
          fqvn = {
            encantador: encantador,
            incantation: incantation,
            version: version
          };
        } else if (typeof fqvn === 'object') {
          encantador = fqvn.encantador;
          incantation = fqvn.incantation;
          version = fqvn.version;
        }
        if (fqvn.book && fqvn.book !== book) {
          book = fqvn.book;
          delete fqvn.book;
        }
        if (!book instanceof StoryBook) {
          debugger;
          console.log("perhaps one of these is the book:", this.refs.book, fqvn.book);
        }
        if (!incantation) {
          console.error("you need a incantation for your blueprint!");
          throw new Error("you need a incantation for your blueprint!");
        }
        if (!encantador) {
          console.error("you need a encantador for your blueprint!");
          throw new Error("you need a encantador for your blueprint!");
        }
        if (!version) {
          version = 'latest';
        }
        long_incantation = encantador + ':' + incantation + '@' + version;
        if (bp = this.blueprints[long_incantation]) {
          if (typeof cb === 'function') {
            return cb(null, bp);
          }
        } else {
          refs = this.refs;
          if (book instanceof StoryBook && book !== refs.book) {
            if (refs.book) {
              refs = import$({}, this.refs);
            }
            refs.book = book;
            this.debug("instantiating this in another poetry book");
          }
          this.blueprints[long_incantation] = bp = new Blueprint(refs, {
            encantador: encantador,
            incantation: incantation,
            version: version
          });
          timeout = setTimeout(function(){
            if (typeof cb === 'function') {
              return cb({
                code: 'TIMEOUT'
              }, bp);
            }
          }, 4000);
          return bp.once_initialized(function(){
            clearTimeout(timeout);
            bp.imbue(book);
            bp.debug("BLUEPRINT IMBUED");
            if (typeof cb === 'function') {
              return cb(null, bp);
            }
          });
        }
      }
    }
  };
  return Library;
}(Fsm));
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}